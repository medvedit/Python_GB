print('Hello world') # print - вывод на печать в консоль.
# Python – язык с динамической типизацией.
#  Переменные: ************************************************************************
# Типы данных справедливы int, float, boolean, str, list и др.
value = None # Можно объявить переменную с пустым значением <None>, а уже далее по коду присвоить значение.
a = 123 #  При объявленни значения в переменную не обязательно присваивать тип, тут тип присвоится сам в int.
#          Мы просто объявляем имя переменной и присваиваем значение.
b = 1.74 # в этом случае тип будет присвоен как float
print(a) # Вывод на печать значения a.
print(type(a)) # Оператор <type> позволяет вывести в консоль тип переменной присвоенный к имяни <a>.
print(b) # Вывод значения b.
print(type(value)) # В данном случае на печать выйдет значение <class 'NoneType'>, тк значение к имяни <value> присвоенно ниже по коду.
value = 2809 # Присвоили значение,
print(type(value))
print(value) #  и вывели его на печать.
print(type(b))
name = 'Sergei' # Объявление строки
name1 = '\"Sergei\"' # Обратные опострофы работают так же, как и языке C# => \", \n, \t ...
print(name1) # => "Sergei"
print(name) #  => Sergei
print(type(name)) # Убеждаемся, что к имяни <name> присвоена строка <class 'str'>

# Итерполяция в языке Python: ******************************************************************************
nam = 123
str = 'Hello world'
nam_1 = 1.47
# Выше тремя строками вводим значения, а ниже пять строк вывода с помощью интерполяции. Возможен к применению любой вариант.
print(nam, nam_1, str) #                               => 123 1.47 Hello world
print(nam, '-', nam_1, '-', str) #                     => 123 - 1.47 - Hello world
print('{} - {} - {}'. format(nam, nam_1, str)) #       => 123 - 1.47 - Hello world
print('{0} - {2} - {1}'. format(nam, nam_1, str)) #    => 123 - Hello world - 1.47
print(f'{nam} - {nam_1} - {str}') #                    => 123 - 1.47 - Hello world

# Логические переменные: **************************************************************************************
f = True
p = False
print(f)
print(p)

# Списки: *********************************************************************
list = [1, 2, 3]  # список целочисленных чисел.
list2 = ['1', '2', '3']  # список строковых значений.
list3 = ['1', '2', 1, 2, 3, 1.34, 0.0394, True] # списки могут содержать разные значения, тк ДИНАМИЧЕСКАЯ типизация. НО кодить так не стоит!
print(list) # [1, 2, 3]
print(list2) # ['1', '2', '3']
print(list3) # ['1', '2', 1, 2, 3, 1.34, 0.0394, True] НО ЛУЧШЕ ДЕРЖАТЬ В ОДНОМ ХРАНИЛИЩЕ ДАННЫЕ ОДНОГО ТИПА!!!

# Ввод и вывод данных о пользователя: *****************************************
# print() - отвечает за вывод данных.
# input() - отвечает за ввод, считывание данных.
print('Введите l: ')  # Просим вести значение. => 5
l = input()  # Считываем значение.
print('Введите d: ') # => 9
d = input()
print(l, d) # => 5 9
print('{} {}'.format(l, d)) # => 5 9
print(f'{d} {l}') # => 9 5
print(l, '+', d, '=', l+d) # Но в выводе мы получим строку 5 + 9 = 59. Про сложение смотрим ниже по коду..
# Сложение в выводе: ********************************************************
print('Введите q: ') # => 5
q = int(input()) # Приводим считанное число к типу int
print('Введите w: ') # => 9
w = int(input()) # Приводим считанное число к типу int
print(q, '+', w, '=', q+w) # => 5 + 9 = 14    Вот в этом случае мы получаем сложение.

# ====================================================================================================== Арефмитичекие операции ==========================================================================================================
# +, -, *, %, //, **, Приоритет операций **, ⊕, ⊖, *, /, //, %, +, - Скобки меняют приоритет ()


# Простое сложение: вычитание и уножение без изменений *******************************************
a1 = 123
b1 = 321
c1 = a1+b1
print(c1) # 444
# Деление: ***************************************************************************************
a3 = 12
b3 = 8
c3 = a3 / b3 # Деление воспринимается как для вещественных чисел
print(c3) # Ответ 1.5
c4 = a3 // b3 # два знака деления выводит ответ в челых числах, целочисленное деление.
print(f'{c4} целое') # Ответ 1 целое
c5 = a3 % b3 # нахождение остатка от деления
print(f'{c5} остаток от деления') # Ответ 4 остаток от деления
# Возведение в степень ****************************************************************************
d2 = 5
g2 = 2
j2 = d2 ** g2 # то есть цифра 5 во 2 степени. Двойное ** означает возведение в степень.
print(f'{j2} => как 5 во 2 степени') # Ответ 25 => как 5 во 2 степени
# В языке Python нет проблем с хранением данных, тк динамическая типизация, по этому:
h2 = 5
k3 = 300
l2 = h2 ** k3
print(f'{h2} в степени {k3} = {l2}') # Ответ 5 в степени 300 = 490909346529772655309577195498627564297521551249944956511154911718710525472171585646009788403733195227718357156513187851316791861042471890280751482410896345225310546445986192853894181098439730703830718994140625
# Решение с унарным минусом: ********************************************************************
a2 = +123 # унарный плюс, так писать можно, но не пишут ))
b2 = -321 # Инверсия числа - унарный минус
c2 = a2+b2
print(c2) # -198
# Перемножение вещественных чисел ***************************************************************
u2 = 1.3
k3 = 3
l4 = u2 * k3
print(l4) # Ответ 3.9000000000000004 Для того что бы убрать нули используется функция round
print(round(l4,1))# 3.9
k6 = 1.3
l5 = 3
d5 = round(k6 * l5, 3) # цифра 3 указывает количество знаков после запятой в выводе ответа
print(d5) # Ответ 3.9
# ЕСЛИ не указывать количество знаков в выводе, то по умолчанию функция round производит математическое округление
k6 = 1.3
l5 = 3
d5 = round(k6 * l5) # Просто округлили ответ до целого числа.
print(d5) # Ответ 4

# Логические операции: ********************************************************************
# >, >=, <, <=, ==, !=
# not, and, or - путают с &, |, ^
# кроме этого еще is, is not, in, not in
w = 1 > 5
print(w)  # False
w = 1 < 5
print(w)  # True
w = 1 < 5 and 5 > 2 # and =>  И
print(w)  # True
w = 1 > 5 and 5 > 2
print(w)  # False
d6 = 'hello'
k4 = 'hello'
l3 = d6 == k4
print(l3)  # True
# ИЛИ
d6 = 'hello'
k4 = 'hello'
print(d6 == k4)  # True
y3 = [17, 24, 3]
l3 = [17, 24, 3]
print(y3 == l3)  # True  сравнение осуществляется поэлементно.
a = 1 < 4 > 3 < 10
print(a)  # True
func = 1
t = 4
x = 123
print(func < t > (x))  # Ответ False
f = 1 > 2 or 4 < 6  # or - ИЛИ
print(f)  # Ответ True
f = [1, 2, 3, 4]
print(f)
print(2 in f)  # ответ True ,то есть мы определяем цифру 2 В списке f
f = [1, 2, 3, 4]
print(f)
print(not 2 in f)  # ответ False ,то есть отрицание not цифры 2 В списке f
k = [1, 4, 5, 6]
is_odd = not k[0] % 2 # проверка четности первого элемента в списке k, нулевой индекс
print(is_odd) # Ответ False
# ===================================================================================================== ФУНКЦИИ ===========================================================================================
# Логические ветвления, управляющие конструкции if, if-else ************************************************************
print('Введите число a: ')
a = int(input())
# a = int(input('a = )) # в одной строке запрос на ввод числа и считывание его.
print('Введите число b: ')
b = int(input())
# b = int(input('b = )) # в одной строке запрос на ввод числа и считывание его.
if a > b:
    print(a)
else:
    print(b)

# ветвление if-else в связке elif ***********************************************************
username = input('Введите имя пользователя: ')
if username == 'Маша':
    print('Ура, это МАША!')
elif username == 'Марина':
    print('Я так ждал Вас, Марина!')
elif username == 'Ильнар':
    print('Ильнар - топ!!!')
else:
    print('Привет, ', username)

# Цикл while ************************************************************
original = 23
print(original % 10) # => 3
inverted = 0
while original != 0:
    inverted = inverted * 10 + (original % 10)
    original //= 10
print(inverted) # => 32
# У цикла while есть блок else
original = 23
inverted = 0
while original != 0:
    inverted = inverted * 10 + (original % 10)
    original //= 10
    print(original) # можно увидеть в консоли работу цикла while
else:
    print('Пожалуй')
    print('Хватит :-)')
print(inverted) # => 32

# Цикл for **********************************************************************
list = [1, 2, 3, 16, 4]
for i in list:  # i - имя, счетчик в списке 1, 2, ...
    print(i**2)  # на вывод выводим квадратов всех чисел из i
# Ответ 1
#       4
#       9
#       256
#       16
# использование range: **********************************************************
r = range(10) # range в данном примере от 0 до 9, цифра 10 не войдет в вывод.
for i in r:
# Или можно сократить
# for i in range(10):
    print(i)
# Ответ 0
#       1
#       2
#       3
#       4
#       5
#       6
#       7
#       8
#       9
for i in range(1, 5): # указали range от 1 до 4
    print(i)
# Ответ 1
#       2
#       3
#       4
for i in range(0, 10, 2): # указали range от 1 до 9, А третий аргумент приращение на 2
    print(i)
# Ответ 0
#       2
#       4
#       6
#       8
for i in range(1, 10, 2): # указали range от 1 до 9, А третий аргумент приращение на 2
    print(i)
# Ответ 1
#       3
#       5
#       7
#       9
for i in 'hello world':
    print(i)
# Ответ h
#       e
#       l
#       l
#       o

#       w
#       o
#       r
#       l
#       d

#  ======================================================================================================= РАБОТА СО СТРОКАМИ ===========================================================================================
text = 'у Лукоморья дуб зеленый, золотая цепь на дубе том'
print(len(text)) # len - количество символов в тексте text, учитывая пробелы => 48
print('дуб'in text) # поиск подстроки в тексте text , в данном случае слово дуб => True
print(text.isdigit()) # text.isdigit являются ли все символы строки числами => False
print(text.islower()) # text.islower являются ли все символы строки символами нижнего регистра => False
print(text.replace('золотая', 'ЗОЛОТАЯ')) # text.replace  заменить символы в строке с ... на ... => у Лукоморья дуб зеленый, ЗОЛОТАЯ цепь на дубе том

# Что бы увидеть справку по встроенным методам, увидеть описание метода нужно:
#help(text.isupper) # help(интересующая функция)
# #                   Справка по встроенной функции isupper:
#                  isupper() экземпляра встроенного объекта.str
#                   Возвращает True, если строка является строкой в верхнем регистре, в противном случае — False.

#                   Строка является прописной, если все символы в строке в верхнем регистре и
#                   в строке есть хотя бы один символ в регистре.
#help(int) # и читаем все о int , выход клавиша Q

#  И снова о строках,  СРЕЗЫ ******************************************************************************
text = 'у_Лукоморья дуб зелёный, златая цепь на дубе том'
print(text[0]) # у
print(text[2]) # Л
print(text[len(text)-1]) # м
print(text[-5]) # е
print(text[:]) # у_Лукоморья дуб зелёный, златая цепь на дубе том
print(text[:2]) # у_
print(text[len(text)-5:]) # е том
print(text[2:9]) # Лукомор
print(text[6:-18]) # морья дуб зелёный, злата
print(text[0:len(text):6]) # умдл я б      от 0 индексы и каждый 6 на вывод
print(text[::6]) # умдл я б
print(text[2:9] + text[-5] + text[:2]) # Лукомореу_

# =========================================================================================================== СПИСКИ ==================================================================================================
# Список - прономерованная, изменяемая коллекция объектов произвольных типов
# *********************************************************************************

list = [1, 2, 3]  # список целочисленных чисел.
list2 = ['1', '2', '3']  # список строковых значений.
list3 = ['1', '2', 1, 2, 3, 1.34, 0.0394, True] # списки могут содержать разные значения, тк ДИНАМИЧЕСКАЯ типизация. НО кодить так не стоит!
print(list) # [1, 2, 3]
print(list2) # ['1', '2', '3']
print(list3) # ['1', '2', 1, 2, 3, 1.34, 0.0394, True] НО ЛУЧШЕ ДЕРЖАТЬ В ОДНОМ ХРАНИЛИЩЕ ДАННЫЕ ОДНОГО ТИПА!!!


numbers = [1, 2, 3, 4, 5]
print(numbers) # [1, 2, 3, 4, 5]

print(f'{len(numbers)} len') # 5 len

ran = range(1, 4)
numbers = list(ran)
print(numbers) # [1, 2, 3]

numbers[0] = 10
print(numbers) # [10, 2, 3, 4, 5]

for i in numbers:
    i *= 2
    print(i) # 20
#              4
#              6
#              8
#              10
print(numbers) # [10, 2, 3, 4, 5]

# *****************************************************************************
list1 = [1, 2, 3, 4, 5]
list2 = list1
# Создали список list1, создали второй список list2 равный первому.
for e in list1:
    print(e)# 1
            # 2
            # 3
            # 4
            # 5

print()

for e in list2:
    print(e)# 1
            # 2
            # 3
            # 4
            # 5

# Далее по коду меняем значение одной переменной в list1 и получаем изменение в list2
print()

list1[0] = 123 # изменяем

for e in list1:
    print(e)# 123
            # 2
            # 3
            # 4
            # 5

print()

for e in list2:
    print(e)# 123
            # 2
            # 3
            # 4
            # 5

# И как же работает с изменением в list2
print()

list2[-1] = 567 # изменяем

for e in list1:
    print(e)# 123
            # 2
            # 3
            # 4
            # 567

print()

for e in list2:
    print(e)# 123
            # 2
            # 3
            # 4
            # 567
# ****************************************************************************************************
# Списки расширенный функционал
colors = ['red', 'green', 'blue'] # Создали список с элементами
print(len(colors)) #  3  Распечатали длину/количество элементов в списке
print(type(colors)) # <class 'list'>

colors1 = colors # Создали новый список colors1 равный первому colors
print(len(colors1)) #  3  Распечатали длину/количество элементов в списке
print(type(colors1)) # <class 'list'>

print()

for e in colors: # печать через цикл
    print(e) # red
#              green
#              blue

for e in colors: # печать умножая на два
    print(e*2) # redred
#                greengreen
#                blueblue
print()

# Добавление и удаление элементов ************************************************

#                                                                !!!!!!!  ВАЖНО ЧТО ЭЛЕМЕНТЫ ДИНАМИЧЕСКИ МЕНЯЮТСЯ ВО ВСЕХ СПИСКАХ !!!!!!!
colors.append('gray') # добавить в конец списка
print(colors) # ['red', 'green', 'blue', 'gray']
print()


print(colors == colors1) # True
print(colors) # ['red', 'green', 'blue', 'gray']
print(colors1) # ['red', 'green', 'blue', 'gray']
print(colors == ['red', 'green', 'blue', 'gray']) # True
print()

colors.pop() # По умолчанию удалит последний элемент в списке, тк аргумент, номер элемента не указан.
print(colors) # ['red', 'green', 'blue']
print(colors) # ['red', 'green', 'blue']
print(colors1) # ['red', 'green', 'blue']            УДАЛЯЕМ ИЗ colors А МЕНЯЕТСЯ В colors1 !!!!!!!!!!!!
print()

colors1.pop(1) # Удалит элемент в аргументом 1 из списка colors1
print(colors1) # ['red', 'blue']
print(colors) # ['red', 'blue']
print()

colors.insert(2, 'yellow') # С помошью функции insert можно указать какой элемент и на какую позицию поставить.
print(colors) # ['red', 'blue', 'yellow']
print(colors1) # ['red', 'blue', 'yellow']
print()

colors.remove('red') # удалить элемент по имяни
print(colors) # ['blue', 'yellow']
print()

del colors[0] # удалить элемент по индексу
print(colors) # ['yellow']
print()



# ================================================================================ ФУНКЦИИ !!!! ============================================================================================
# Функция - фрагмент программы используемый многократно:

arg = 2.3
def data_type(x):
    if x == 1:
        return 'целое число'
    elif x == 2.3:
        return 23
    else:
        return
print(data_type((arg))) # => 23
print(type(data_type(arg))) # => <class 'int'>

