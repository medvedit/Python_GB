# # =========================================================================== Файлы ====================================================================================================================

# # Хранение данных
# # Передача данных в клиент-серверных проектах
# # Хранение конфигов
# # Логирование действий
# # *********************************************
# # Как работать с файлами:
# # Связать файловую переменную с файлом,
# # определив модификатор работы
# # a – открытие для добавления данных
# # r – открытие для чтения данных
# # w – открытие для записи данных
# # w+, r+
# # *********************************************
# # один из вариантов создания файла, работы с ним, с автомотическим разрывом соединения по зваершении работы кода.
# with open('file.txt', 'w') as data:
#     data.write('line 1\n')
#     data.write('line 2\n')
# # ************************************
# # один из вариантов создания файла, работы с ним, с принудительным закрытием связи с файлом .txt путем команды data.close()
# colors = ['red', 'green', 'blue']
# data = open('file.txt', 'w') # Создаем файл file.txt , создается он в корневой, первой папке.
# data.writelines(colors) # Заносим текст из переменной colors, разделителей не будет.
#                         # Приповторном запуске, данные будут дописываться.
# data.write('\n112233\n')
# data.write('445566\n')
# data.close() # Закрываем, разрываем связь с файлот file.txt .
# # ***********************************
#                                                   exit() # отключает выполнение кода ниже.
# # Считываем данные и файла
# path = 'file.txt' # Создаем путь
# data = open(path, 'r') # Открываем
# for line in data: # С помощью цикла проходим по всем элементам
#     print(line) # Выводим в консоль содержимое файла
# data.close() # Разрываем связь
# # ************************************

# # ================================================================================ Функции и модули ====================================================================================================

# # Функции - это это фрагмент программы, используемый  многократно.

# import Lecture_1 # обращяемся к соседнему файлу

# print(Lecture_1.data_type(1)) # Выводим на печать (имя файла.название функции(входящий аргумент))

# import Lecture_1 as L # обращяемся к соседнему файлу + к которому создалиассоциацию как буква L и ниже уже обращяемся по букве L

# print(L.data_type(1)) # Выводим на печать (имя файла.название функции(входящий аргумент))
# print(type(L.data_type(1))) # Вывод типа данных

# # *****************************************
# def new_string(symvol, count): # Предположим есть функция принимающяя на вход символ и число
#     return symvol * count  # на выходе мы умножаем символ на число

# print(new_string('!', 5))     # !!!!!
# print(new_string('!'))        # TypeError missing 1 required ... тк нет второго вхлдящего элемента

# def new_string(symbol, count = 3): # можно присвить число сазу и если не вводим цисло на вывод, будет использоваться три.
#     return symbol * count
# print(new_string('!', 5)) # !!!!!
# print(new_string('!')) # !!!
# print(new_string(4)) # 12 # Тут, так как нет на вод строки, а только число - происходит умножение 4 на 3 = 12
# # ******************************************
# #  Возможность передачи не ограниченого колличества аргументов
# def concatenatio(*params): # Создали функцию со звездочкой перед аргументом
#     res: str = "" # работа со стоками
#     for item in params: # цикл
#         res += item # складываем строчные элементы
#     return res # результат
# print(concatenatio('a', 's', 'd', 'w')) # asdw
# print(concatenatio('a', '1', 'd', '2')) # a1d2
# # print(conatenatio(1, 2, 3, 4)) # TypeError: ...

# def concatenatio(*params): # Создали функцию со звездочкой перед аргументом
#     res: int = 0 # работа с числами
#     for item in params: # цикл
#         res += item # складываем числа
#     return res # результат
# # print(concatenatio('a', 's', 'd', 'w')) # TypeError: ...
# # print(concatenatio('a', '1', 'd', '2')) # TypeError: ...
# print(concatenatio(1, 2, 3, 4)) # 10
# # ******************************************
# # ================================================================================================== Рекурсия =================================================================================================================================

# def fib(n): # функция вычесления фиюоначи
#     if n in [1, 2]:
#         return 1
#     else:
#         return fib(n-1) + fib(n-2) # Запуск рекурсии

# ddd = [] # создали переменную для вывода
# for i in range(1, 10): # прошли циклом в заданном ренже
#     ddd.append(fib(i)) # сохранили значения из функции fib с помощью цикла
# print(ddd)                 # 1 1 2 3 5 8 13 21 34
# print(type(ddd))           # <class 'list'>

# # ================================================================================================= Кортежи ===========================================================================================================

# # Кортеж (tuple) – это неизменяемый “список” ************************************
# a, b = 2, 3    #  переменной a и b присвоили значение 2 и 3
# a = (2, 3, 4)     # уже картеж
# print(a)       # (2, 3, 4)
# print(type(a)) # <class 'tuple'>
# print(a[0])    # в кортеже можно обрящятся к элементу - 2
# print(a[-1])   # 4
# # **********************************************
# t = ()
# print(type(t)) # tuple
# t = (1,)
# print(type(t)) # tuple
# t = (1)
# print(type(t)) # int
# t = (28, 9, 1990)
# print(type(t)) # tuple
# colors = ['red', 'green', 'blue']
# print(colors) # ['red', 'green', 'blue']
# t = tuple(colors)
# print(t) # ('red', 'green', 'blue')
# # *********************************************
# t = tuple(['red', 'green', 'blue'])
# print(t[0]) # red
# print(t[2]) # blue
# # print(t[10]) # IndexError: tuple index out of range
# print(t[-2]) # green
# # print(t[-200]) # IndexError: tuple index out of range
# for e in t:
#     print(e) # red green blue
# t[0] = 'black' # TypeError: 'tuple' object does not support item assignment Явно изменить или присвоить начение элемента вкартеже мы не можем  !!!!!!!!!!!!!!!!!!!!!!!!!!
# # **********************************************
# t = tuple(['red', 'green', 'blue', 'jj']) # Создали список и преобразовали его в картеж
# red, green, blue, u = t # преобразовали картеж в рти независимых преременные
# print(type(t)) # <class 'tuple'>
# print('r:{} g:{} b:{} u:{}'.format(u, red, green, blue)) # r:red g:green b:blue
# # И далее работаем как с независимыми переменными.

# ===================================================================================================== Словари ==================================================================================================================================
# Словари - это неупорядоченные коллекции произвольных
# объектов с доступом по ключу

dictionary = {} # Создали словарь
dictionary = \
{                  # Присвоили значение к словарю по ключу
'up': '↑',    # В данном примере ключе является 'up' , а значением '↑'
'left': '←',
'down': '↓',
'right': '→'
}
print(dictionary) # {'up':'↑', 'left':'←', 'down':'↓', 'right':'→'}  Распечатать весь словарь
print(dictionary['left']) # ←  Обращение к значению по ключу
print(dictionary['up']) # ↑

for k in dictionary.keys():
    print(k)    # up
                # left
                # down
                # right
for k in dictionary.values():
    print(k)    #  ↑
                #  ←
                #  ↓
                #  →

print(dictionary['left']) # ← Значение было
dictionary['left'] = '⇐' # Значение меняем
print(dictionary['left']) # ⇐ Значение стало

#print(dictionary['type']) # KeyError: 'type'

del dictionary['left'] # удаление элемента

for item in dictionary: # for (k,v) in dictionary.items():
    print('{}: {}'.format(item, dictionary[item]))
                                                    # up: ↑
                                                    # down: ↓
                                                    # right: →


