# # =========================================================================== Файлы ====================================================================================================================

# # Хранение данных
# # Передача данных в клиент-серверных проектах
# # Хранение конфигов
# # Логирование действий
# # *********************************************
# # Как работать с файлами:
# # Связать файловую переменную с файлом,
# # определив модификатор работы
# # a – открытие для добавления данных
# # r – открытие для чтения данных
# # w – открытие для записи данных
# # w+, r+
# # *********************************************
# # один из вариантов создания файла, работы с ним, с автомотическим разрывом соединения по зваершении работы кода.
# with open('file.txt', 'a') as data:
#     data.write('line 1664')
#     data.write('line 2')
# # ************************************
# # один из вариантов создания файла, работы с ним, с принудительным закрытием связи с файлом .txt путем команды data.close()
# colors = ['red', 'green', 'blue']
# data = open('file.txt', 'a') # Создаем файл file.txt , создается он в корневой, первой папке.
# data.writelines(colors) # Заносим текст из переменной colors, разделителей не будет.
#                         # Приповторном запуске, данные будут дописываться.
# data.write('\n112233\n')
# data.write('445566\n')
# data.close() # Закрываем, разрываем связь с файлот file.txt .
# # ***********************************
#                                                   exit() # отключает выполнение кода ниже.
# # Считываем данные и файла
# path = 'file.txt' # Создаем путь
# data = open(path, 'r') # Открываем
# for line in data: # С помощью цикла проходим по всем элементам
#     print(line) # Выводим в консоль содержимое файла
# data.close() # Разрываем связь
# # ************************************

# # ================================================================================ Функции и модули ====================================================================================================

# # Функции - это это фрагмент программы, используемый  многократно.

# import Lecture_1 # обращяемся к соседнему файлу

# print(Lecture_1.data_type(1)) # Выводим на печать (имя файла.название функции(входящий аргумент))

# import Lecture_1 as L # обращяемся к соседнему файлу + к которому создалиассоциацию как буква L и ниже уже обращяемся по букве L

# print(L.data_type(1)) # Выводим на печать (имя файла.название функции(входящий аргумент))
# print(type(L.data_type(1))) # Вывод типа данных

# # *****************************************
# def new_string(symvol, count): # Предположим есть функция принимающяя на вход символ и число
#     return symvol * count  # на выходе мы умножаем символ на число

# print(new_string('!', 5))     # !!!!!
# print(new_string('!'))        # TypeError missing 1 required ... тк нет второго вхлдящего элемента

# def new_string(symbol, count = 3): # можно присвить число сазу и если не вводим цисло на вывод, будет использоваться три.
#     return symbol * count
# print(new_string('!', 5)) # !!!!!
# print(new_string('!')) # !!!
# print(new_string(4)) # 12 # Тут, так как нет на вод строки, а только число - происходит умножение 4 на 3 = 12
# # ******************************************
# #  Возможность передачи не ограниченого колличества аргументов
# def concatenatio(*params): # Создали функцию со звездочкой перед аргументом
#     res: str = "" # работа со стоками
#     for item in params: # цикл
#         res += item # складываем строчные элементы
#     return res # результат
# print(concatenatio('a', 's', 'd', 'w')) # asdw
# print(concatenatio('a', '1', 'd', '2')) # a1d2
# # print(conatenatio(1, 2, 3, 4)) # TypeError: ...

# def concatenatio(*params): # Создали функцию со звездочкой перед аргументом
#     res: int = 0 # работа с числами
#     for item in params: # цикл
#         res += item # складываем числа
#     return res # результат
# # print(concatenatio('a', 's', 'd', 'w')) # TypeError: ...
# # print(concatenatio('a', '1', 'd', '2')) # TypeError: ...
# print(concatenatio(1, 2, 3, 4)) # 10
# # ******************************************
# # ================================================================================================== Рекурсия =================================================================================================================================

# def fib(n): # функция вычесления фиюоначи
#     if n in [1, 2]:
#         return 1
#     else:
#         return fib(n-1) + fib(n-2) # Запуск рекурсии

# ddd = [] # создали переменную для вывода
# for i in range(1, 10): # прошли циклом в заданном ренже
#     ddd.append(fib(i)) # сохранили значения из функции fib с помощью цикла
# print(ddd)                 # 1 1 2 3 5 8 13 21 34
# print(type(ddd))           # <class 'list'>

# # ================================================================================================= Кортежи ===========================================================================================================

# # Кортеж (tuple) – это неизменяемый “список” ************************************
# a, b = 2, 3    #  переменной a и b присвоили значение 2 и 3
# a = (2, 3, 4)     # уже картеж
# print(a)       # (2, 3, 4)
# print(type(a)) # <class 'tuple'>
# print(a[0])    # в кортеже можно обрящятся к элементу - 2
# print(a[-1])   # 4
# # **********************************************
# t = ()
# print(type(t)) # tuple
# t = (1,)
# print(type(t)) # tuple
# t = (1)
# print(type(t)) # int
# t = (28, 9, 1990)
# print(type(t)) # tuple
# colors = ['red', 'green', 'blue']
# print(colors) # ['red', 'green', 'blue']
# t = tuple(colors)
# print(t) # ('red', 'green', 'blue')
# # *********************************************
# t = tuple(['red', 'green', 'blue'])
# print(t[0]) # red
# print(t[2]) # blue
# # print(t[10]) # IndexError: tuple index out of range
# print(t[-2]) # green
# # print(t[-200]) # IndexError: tuple index out of range
# for e in t:
#     print(e) # red green blue
# t[0] = 'black' # TypeError: 'tuple' object does not support item assignment Явно изменить или присвоить начение элемента вкартеже мы не можем  !!!!!!!!!!!!!!!!!!!!!!!!!!
# # **********************************************
# t = tuple(['red', 'green', 'blue', 'jj']) # Создали список и преобразовали его в картеж
# red, green, blue, u = t # преобразовали картеж в рти независимых преременные
# print(type(t)) # <class 'tuple'>
# print('r:{} g:{} b:{} u:{}'.format(u, red, green, blue)) # r:red g:green b:blue
# # И далее работаем как с независимыми переменными.

# # ===================================================================================================== Словари ==================================================================================================================================
# # Словари - это неупорядоченные коллекции произвольных
# # объектов с доступом по ключу

# dictionary = {} # Создали словарь
# dictionary = \
# {                  # Присвоили значение к словарю по ключу
# 'up': '↑',    # В данном примере ключе является 'up' , а значением '↑'
# 'left': '←',
# 'down': '↓',
# 'right': '→'
# }
# print(dictionary) # {'up':'↑', 'left':'←', 'down':'↓', 'right':'→'}  Распечатать весь словарь
# print(dictionary['left']) # ←  Обращение к значению по ключу
# print(dictionary['up']) # ↑

# for k in dictionary.keys():
#     print(k)    # up
#                 # left
#                 # down
#                 # right
# for k in dictionary.values():
#     print(k)    #  ↑
#                 #  ←
#                 #  ↓
#                 #  →

# print(dictionary['left']) # ← Значение было
# dictionary['left'] = '⇐' # Значение меняем
# print(dictionary['left']) # ⇐ Значение стало

# #print(dictionary['type']) # KeyError: 'type'

# del dictionary['left'] # удаление элемента

# for item in dictionary: # for (k,v) in dictionary.items():
#     print('{}: {}'.format(item, dictionary[item]))
#                                                     # up: ↑
#                                                     # down: ↓
#                                                     # right: →


# =========================================================================================================== МНОЖЕСТВА =====================================================================================================================
# Множества (set) - неупорядоченная совокупность элементов

a = {1, 2, 3, 5, 8}
b = {'2', '5', 8, 13, 21}
l = {1, 1, 1, 1, 1}
print(a) # {1, 2, 3, 5, 8}
print(type(a)) # <class 'set'>
print(b) # {'2', '5', 8, 13, 21}
print(type(b)) # <class 'set'>
print(l) # {1}
print(type(l)) # <class 'set'>
# print(type(b[1])) # TypeError: 'set' object is not subscriptable
# ******************************************************************
# Добовление в множества:
print()
a.add(1) # В множество a хочу добавить элемент 1. Но тк он в этом множестве уже есть добавление не происходит.
print(a) # Печать после добавления {1, 2, 3, 5, 8}
print()
a.add(4) # хочу добавить 4. И тк его небыло ранее в множестве, 4 добавляется.
print(a) # {1, 2, 3, 4, 5, 8}
print()
b.add('red')
print(b) # {'red', 21, '5', 8, '2', 13}
# *****************************************************************
# Удаление из множества:
print()
print(b) # {'red', 21, '5', 8, '2', 13}
b.remove('red')
print(b) # {21, 8, '5', 13, '2'}
# b.remove('red') # KeyError: 'red' тк элемент не существует уже во множестве. Но был ранее удален.
b.discard('red') # Можно удалять элементы с помошью этого метода, и если элемент есть - его удалит,
#                  а если нет, то ошибку в этом случае код не выдаст, продолжит работу. discard - отбрасывать.
# *******************************************************************
# Осистка множества:
print()
print(a) # {1, 2, 3, 4, 5, 8}
print(b) # {'2', 21, 8, '5', 13}
print()
a.clear() # Очистить множесво a.
print(a) # set()
print(b) # {'2', 21, 8, '5', 13}
# *******************************************************************
# Копирование и обьеденинение множеств:
print()
a = {1, 2, 3, 5, 8} # {1, 2, 3, 5, 8}
b = {2, 5, 8, 13, 21} # {2, 5, 8, 13, 21}
c = a.copy() # Создать множество c на основн множества a.
print(c) # {1, 2, 3, 5, 8}
print()
u = a.union(b) # Обьединение двух множеств
print(u) # {1, 2, 3, 5, 8, 13, 21}
print()
# *********************************************************************
# Пересичение, разница и разница + рересичение:
print()
a = {1, 2, 3, 5, 8} # {1, 2, 3, 5, 8}
b = {2, 5, 8, 13, 21} # {2, 5, 8, 13, 21}
i = a.intersection(b) # Нахожу общие пересичения из двух множеств a и b.
print(i) #             {8, 2, 5}

print()
a = {1, 2, 3, 5, 8} # {1, 2, 3, 5, 8}
b = {2, 5, 8, 13, 21} # {2, 5, 8, 13, 21}
al = a.difference(b) # Ищу разницу во множестве a, сравнивая с b.
print(al) # {1, 3}

print()
a = {1, 2, 3, 5, 8} # {1, 2, 3, 5, 8}
b = {2, 5, 8, 13, 21} # {2, 5, 8, 13, 21}
br = b.difference(a) # Ищу разницу во множестве b, сравнивая с a.
print(br) # {13, 21}

print()
a = {1, 2, 3, 5, 8} # {1, 2, 3, 5, 8}
b = {2, 5, 8, 13, 21} # {2, 5, 8, 13, 21}
q = a.union(b).difference(a.intersection(b)) # Из общего множества a и b ищу разницу (+) в пересичении a и b .
print(q) # {1, 21, 3, 13}
# *********************************************************************
# Заморозить множество, создать не изменяемое множество:
print()
a = {1, 2, 3, 5, 8} # {1, 2, 3, 5, 8}
f = frozenset(a)
print(f) # frozenset({1, 2, 3, 5, 8})
# f.add(4) # AttributeError: 'frozenset' object has no attribute 'add'
# *********************************************************************
# Приобразование из list в set
print()
j = [1, 2, 3, 7, 45]
print(type(j)) # <class 'list'>
print(j) # [1, 2, 3, 7, 45]
print()
jj = set([1, 2, 3, 7, 45])
print(type(jj)) # <class 'set'>
print(jj) # {1, 2, 3, 7, 45}

print()
dd = set(j)
print(type(dd)) # <class 'set'>
print(dd) # {1, 2, 3, 7, 45}

