#  Ресурс DOCS-PYTHON.RU посвящен языку программирования Python3 и представляет из себя справочную документацию. https://docs-python.ru
# ======================================================= Методы в str (строка): ==============================================================

#          'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map',
#          'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable',
#          'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'removeprefix',
#          'removesuffix', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines',
#                             'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'

# =============================================================================================================================================
#                                                    ________Базовые операции________
# Конкатенация (сложение) __________
s1 = 'spam'
s2 = 'eggs'
print(s1 + s2) # # spameggs

# Дублирование строки ___________
# print('spam' * 3)
s = 'spam'
s1 = 'spam' * 3
print(s1) # spamspamspam

# Длина строки (функция len) __________
print(len(s1)) # 12

# Доступ по индексу __________
s2 = 'kdfj4i44olw'
print(s2[2]) # f
print(s2[-1]) # w
print(s2[4]) # 4

# Извлечение среза ___________
# Оператор извлечения среза: [X:Y]. X – начало среза, а Y – окончание;
# символ с номером Y в срез не входит. По умолчанию первый индекс равен 0, а второй - длине строки.
print(s2[3:5]) # j4
print(s2[2:-2]) # fj4i44o
print(s2[:6]) # kdfj4i
print(s2[1:]) # dfj4i44olw
print(s2[:]) # kdfj4i44olw

# Кроме того, можно задать шаг, с которым нужно извлекать срез.
print(s2[::-1]) # wlo44i4jfdk
print(s2[5:3:-1]) # i4
print(s2[2::2]) # f44ow

# При вызове методов необходимо помнить, что строки в Python относятся к категории неизменяемых последовательностей,
# то есть все функции и методы могут лишь создавать новую строку.
s = 'spam'
# s[1] = 'b' # TypeError: 'str' object does not support item assignment

s1 = s[0] + 'b' + s[2:] # индекс 0 + b + всё со второго индекса. итог - замена 1 индекса
print(s1) # sbam

# ___________________________________________________ 'capitalize'(печатать прописными буквами) ___________________________________________________
# Переводит первый символ/букву строки в верхний регистр.
x = 'первый символ теперь пОмещается в Заглавный, а не в верХний регистр'
print(x.capitalize()) # Первый символ теперь помещается в заглавный, а не в верхний регистр
x2 = x.capitalize()
print(x2) # Первый символ теперь помещается в заглавный, а не в верхний регистр

x = 'ПОМЕЩАЕТСЯ В ЗАГЛАВНЫЙ, А НЕ В ВЕРХНИЙ РЕГИСТР'
print(x.capitalize()) # Помещается в заглавный, а не в верхний регистр
x2 = x.capitalize()
print(x2) # Помещается в заглавный, а не в верхний регистр

# ____________________________________________________________ 'casefold' (чехол) _________________________________________________________________
# Метод .casefold() используется для реализации сопоставления строк без регистра.
# Сворачивание регистра похоже на использование нижнего регистра,
# но более агрессивно, потому что функция casefold() более агрессивна,
# поскольку она преобразует все строковые символы в строчные.
# Она предназначена для удаления всех различий в регистре в строке.
# Функция casefold() не принимает никаких параметров.
# Функция casefold()  возвращает копию строки с свернутым регистром,
# т.е. строка преобразуется в нижний регистр. Это не изменяет исходную строку.

# Пример 1. Преобразование строки в нижний регистр с помощью casefold()
text = "PYTHON CASEFOLD EXAMPLE"
print ("Строчная строка:", text.casefold()) # Строчная строка: python casefold example

# Пример 2. Сравнение строк с помощью функции casefold()
str1 = "Pythonß"
str2 = "Pythonss"
# ß в немецком эквивалентно ss
if str1.casefold() == str2.casefold():
    print('Данные строки равны.')
else:
    print('Данные строки не равны.')
#  >>> Данные строки равны.

# ____________________________________________________________ 'center' (центр) _________________________________________________________________
# Функция str.center() в Python возвращает центрированную строку указанного размера.
# Мы также можем указать символ, который будет использоваться для заполнения, по умолчанию – пробел.
# Синтаксис функции:
# str.center(ширина[, заполняющий символ])
s = 'Hello'
s1 = s.center(20)       # Значение хранящееся в переменной s отцентрованы на 20 пунктов,
                        # и новое значение записали в переменную s1
print(f'***{s1}***')    # ***       Hello        ***

s = 'Hello'
s1 = s.center(20, '_')  # Значение хранящееся в переменной s отцентрованы на 20 пунктов,
                        # добавили символ вместо пробела,
                        # и новое значение записали в переменную s1
print(f'***{s1}***')    # ***_______Hello________***

s = 'Hello World' # в переменной s храниться строка состоящая из 11 знаков,
                  # по этому только при значении выше 11 знаков появляется символ *
print(s.center(6, '*')) # Hello World
print(s.center(12, '*')) # Hello World*
print(s.center(11, '*')) # Hello World

# ____________________________________________________________ 'count' (считать) _________________________________________________________________
# Метод str.count() в Python, считает совпадения в строке.
# При вызове без аргументов бросает исключение TypeError (требуется как минимум 1 аргумент, передано 0).
# Синтаксис:
            # str.count(sub[, start[, end]]) -> int (возвращает целое число, количество вхождений в искомой строке)
# Параметры:
            # sub - str, строка или символ;
            # start - int, индекс начала поиска, по умолчанию 0, необязательно;
            # end - int, конец, индекс конца поиска, по умолчанию len(str), необязательно.
# Описание:
            # Метод str.count() позволяет узнать сколько раз указанный элемент x появился в
            # последовательности str.
            # Результатом будет целое число, показывающее количество вхождений элемента x в
            # последовательность str.
            # Другими словами, сколько раз указанный элемент x появляется в последовательности или
            # сколько раз встречается буква/символ/подстрока в какой либо строке.
            # Элементом может быть символ или подстрока, если последовательность строка.
            # Число, если это числовая последовательность и т. д.
            # Эта операция поддерживаются большинством типов последовательностей, как изменяемых,
            # так и неизменяемых.

            # Примечание: Множества set и frozenset не поддерживает метод .count(), т. к.
            #             это неупорядоченная коллекция без повторяющихся элементов.
x = 'кукуруза'
x1 = x.count('у')
print(x1) # 3
print(type(x1)) # <class 'int'>

x2 = 'ку'
print(x.count(x2)) # 2

print(x.count('o')) # 0


x = [2, 1, 3, 1, 6, 1, 8, 8, 98, 11]
x1 = 1
print(x.count(x1)) # 3

print(x.count(8)) # 2

print(x.count(10)) # 0

x = 'количество вхождений подстроки `sub` в диапазоне индексов'
x1 = x.count('и') # сохранили результат в переменную x1
print('количество букв "и" ровно int',x1) # количество букв "и" ровно int 5
print(type(x1)) # <class 'int'>

print(x.count('и', 6)) # 4

print(x.count('о', 10, 30)) # 3

print(x.count('`')) # 2

print(x.count('вхождений')) # 1

# Без параметров
# print(x.count())
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# TypeError: count() takes at least 1 argument (0 given)

# ____________________________________________________________ 'encode' (кодировать) _________________________________________________________________
# Метод str.encode() в Python, преобразует строку в байты.
# Синтаксис:
            # str.encode(encoding="utf-8", errors="strict")
# Параметры:
            # encoding - str, используемая кодировка строки, по умолчанию utf-8
            # errors - обработчик ошибок кодировки.
# Возвращаемое значение:
                        # bytes, байтовая версия строки.
# Описание:
            # Метод str.encode() вернет закодированную версию строки str как объект байтов.
            # Другими словами кодирует текстовую строку str в строку байтов (https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-bytes-bajtovye-stroki/),
            # используя указанную кодировку encoding.
            # Аргумент encoding по умолчанию используется 'utf-8'.
            # Для получения списка всех схем кодирования смотрите https://docs.python.org/3/library/codecs.html#standard-encodings
            # Аргумент errors может быть задан для установки другой схемы обработки ошибок.
            # Значение по умолчанию для ошибок является 'strict', это означает,
            # что при ошибке кодирования будет подниматься исключение UnicodeError.
            # Другие стандартные значения обработчика ошибок, это 'ignore', 'replace',
            # 'xmlcharrefreplace', 'backslashreplace' или любое другое значение,
            # зарегистрированное с помощью codecs.register_error() (https://docs-python.ru/standart-library/modul-codecs-python/registratsija-novogo-obrabotchika-oshibok/).

# Стандартные схемы обработки ошибок:
                                    # strict - возбуждается UnicodeError, при попадании ошибочных символов*;
                                    # ignore - ошибочных символов* пропускаются;
                                    # replace - ошибочных символов* заменяются на ?;
                                    # xmlcharrefreplace - ошибочных символов* заменяются на соответствующее им XML-представление;
                                    # backslashreplace - ошибочных символов* заменяются на последовательности, начинающиеся с обратной косой черты;
                                    # namereplace - ошибочных символов* заменяются на последовательности вида \N{...};
                                    # surrogateescape - заменяет каждый байт на код суррогата, от U+DC80 до U+DCFF;
                                    # surrogatepass - игнорирует коды суррогатов. Используется со следующими кодеками: utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le;
                                    # *ошибочные символы - это символы, которые не поддерживаются указанной encoding кодировкой.

x = 'кодирует в строку байтов'
# У закодированной строки появился литерал 'b' - стока байтов
x1 = x.encode('utf-8') # получаем строку байтов, результат записали в переменную x1
print(x1)   # b'\xd0\xba\xd0\xbe\xd0\xb4\xd0\xb8\xd1\x80\xd1\x83\xd0\xb5\xd1\x82 /
            # \xd0\xb2 \xd1\x81\xd1\x82\xd1\x80\xd0\xbe\xd0\xba\xd1\x83 /
            # \xd0\xb1\xd0\xb0\xd0\xb9\xd1\x82\xd0\xbe\xd0\xb2'


# print(x.encode('ascii')) # В кодировке ascii нет русских букв - утверждаем в данном контексте,
                         #  и по этому на выходе получим ошибку.
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# UnicodeEncodeError: 'ascii' codec can't encode characters in
# position 0-7: ordinal not in range(128)

print(x.encode('ascii', errors='ignore'))   # Тут мы тоже утверждаем, что в значениях строки x нет русских букв,
                                            # НО затем указали, что если русская буква встретится,
                                            # то errors='ignore', т.е. пропустим ошибку, и пойдем проверять текст до последнего символа.
# Ответ:
        # b'   '

print(x.encode('ascii', errors='replace'))  # Здесь подобная утверждение и проверка,
                                            # за исключением errors='replace'.
                                            # В этом решении вместо каждого ошибочного символа появится знак ? .
# ответ:
        # b'???????? ? ?????? ??????'

# ____________________________________________________________ 'endswith' (заканчивается) _________________________________________________________________
#  Метод str.endswith() в Python, совпадение с концом строки.
# Синтаксис:
                # str.endswith(suffix[, start[, end]])
#  Параметры:
                # suffix - объект поддерживающий итерацию (кортеж, символ или подстрока).
                # start - int, индекс начала поиска, по умолчанию 0, необязательно.
                # end - int, индекс конца поиска, по умолчанию len(str), необязательно.
# Возвращаемое значение:
                        # bool, True, если суффикс suffix совпал.
#  Описание:
            # Метод str.endswith() возвращает True, если строка str заканчивается указанным суффиксом suffix,
            # в противном случае возвращает False.
            # Ограничивать поиск окончания строки можно необязательными индексами start и end.
            # В этом случае суффиксом suffix будет искаться в конце среза.
            # Суффикс suffix также может быть кортежем суффиксов для поиска.
            # Необязательные аргументы start и end интерпретируются как обозначения среза строки и передаются как позиционные аргументы
            # При вызове без аргументов бросает исключение TypeError (требуется как минимум 1 аргумент, передано 0).

x = 'заканчивается указанным суффиксом suffix'
x1 = x.endswith('suffix')
print(x1) # True

print(x.endswith('иксом')) # False

print(x.endswith('иксом',0 ,-7)) # True

# Есть список строк
x = ['возвращает True',
    'если строка str',
    'заканчивается указанным',
    'суффиксом suffix']
print(type(x)) # <class 'list'>

suffix = ('ue', 'str', 'fix') # Нужны строки, заканчивающиеся на суффиксы

for item in x:
    if item.endswith(suffix):
        print('OK =>', item)
    else:
        print('NO =>', item)
# Ответ после выполнения цикла:
                                # OK => возвращает True
                                # OK => если строка str
                                # NO => заканчивается указанным
                                # OK => суффиксом suffix

# Альтернативное написание цикла. В примере, обратная косая черта (\) в конце строк -
# это знак переноса длинных однострочных выражений.
# Дополнительно смотрите PEP 8 -> https://docs-python.ru/tutorial/pep-rukovodstvo-stilju-koda-python/razmetka-koda-pep/
# for item in x:
#     print('OK =>', item) \
#     if item.endswith(suffix) \
#     else print('NO =>', item)

# ____________________________________________________________ 'expandtabs' (замена табуляции) _________________________________________________________________
# Метод str.expandtabs() в Python, меняет табуляцию на пробел.
# Синтаксис:
            # str.expandtabs(tabsize = 8)
# Параметры:
            # tabsize = 8 - int, количество пробелов для заменены табуляции, по умолчанию 8.
# Возвращаемое значение:
                        # измененная копия строки
# Описание:
            # Метод str.expandtabs() возвращает копию строки str,
            # в которой все символы табуляции \t (https://docs-python.ru/tutorial/strokovye-bajtovye-literaly/escape-posledovatelnosti-python/)
            # заменяются одним или несколькими пробелами,
            # в зависимости от текущего столбца и заданного размера табуляции tabsize.

            # Для замены табуляций изначально номер столбца задаётся равным нулю и начинается посимвольный обход строки.
            # При обходе строки str, если попадается символ табуляции \t,
            # то на его место вставляется столько пробелов,
            # что бы текущий номер столбца стал равным позиции следующей табуляции.
            # При этом сам символ табуляции не копируется.

            # Если встречается символ переноса строки \n или возврата каретки \r,
            # то он сохраняется в строке, а текущий номер столбца сбрасывается на 0.
            # Любой другой символ копируется без изменений, а текущий столбец увеличивается на единицу.

x = '01\t012\t0123\t01234'
print(x) # '01      012     0123    01234'
print(x.expandtabs()) # '01      012     0123    01234'

x1 = '01\t012\t0123\t01234'
print(x.expandtabs(4)) # '01  012 0123    01234'


# Есть список строк
x = ['Метод возвращает копию строки',
     'которой все символы табуляции',
     'заменяются одним или несколькими',
     'пробелами зависимости текущего столбца']

# Нужно слова в строках с расставить по
# столбцам, например, для лучшей наглядности

for item in x:
    item = item.replace(' ', '\t') # восстановит в строку вместо пробелов знак табуляции
    s = item.expandtabs(13) # вместо знака табуляции пропуск в печати последующего слова,
                            # от первого знака текущего слова,
                            # до первого знака последующего слова в 13 знаков.
    print(s) # построчно печатает каждый разбор.
# Ответ:
        # 1234567890123
        # Метод        возвращает   копию        строки
        # которой      все          символы      табуляции
        # заменяются   одним        или          несколькими
        # пробелами    зависимости  текущего     столбца

# ____________________________________________________________ 'find' (найти) _________________________________________________________________
# Метод str.find('text', start, end) в Python, поиск подстроки в строке

# Он имеет три формы и возвращает индекс 1-го вхождения подстроки в строку:
#  .find('text'): поиск подстроки str производится с начала строки и до её конца;
#  .find('text', start): с помощью параметра start задаётся начальный индекс, и именно с него и выполняется поиск;
#  .find('text', start, end): посредством параметра end задаётся конечный индекс, поиск выполняется до него.
# Когда подстрока не найдена, метод возвращает -1:

welcome = "Hello world! Goodbye world!"
index = welcome.find("wor") # ищем начало вхождения, индекс и записываем его в переменную index
print(index)       # 6
print(type(index)) # <class 'int'>

# ищем с десятого индекса
index = welcome.find("wor",10)
print(index)       # 21

# ищем с 10-го по 15-й индекс
index = welcome.find("wor",10,15)
print(index)       # -1 (значение не найдено)

# ____________________________________________________________ 'format' (формат) _________________________________________________________________

# Форматирует строку методом format(). https://docs-python.ru/tutorial/operatsii-tekstovymi-strokami-str-python/metod-str-format/

# Функция format() в Python, форматирует значение переменной. https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-format/

# Очень большая тема. Читать по ссылкам.

# ____________________________________________________________ 'format_map' (формат карты) _________________________________________________________________
# Метод форматирования str.format_map()

# Синтаксис:
                # str.format_map(mapping)
# Параметры:
                # mapping - подкласс словаря dict.
# Возвращаемое значение:
                        # str, копия форматированной строки
# Описание:
            # Метод str.format_map() работает аналогично str.format(**mapping), за исключением того, что mapping используется напрямую и не копируется в словарь dict.
            # Это полезно, если, например mapping, подкласс dict.
class Default(dict):
    def __missing__(self, key):
        return key

print('{name} was born in country'.format_map(Default(name='Guido'))) # 'Guido was born in country'

# ____________________________________________________________ 'index' (индекс/указатель) _________________________________________________________________
# Возвращает индекс первого совпадения начала символа/подстроки.
# Синтаксис:
            # str.index(sub[, start[, end]])
# Параметры:
            # sub - str, подстрока или символ;
            # start - int, индекс строки str для начала поиска;
            # end - int, индекс строки str для конца поиска.
# Возвращаемое значение:
                        # int, индекс позиции в строке.
# Описание:
            # Метод str.index() возвращает индекс первого совпадения начала подстроки sub в строке str,
            # где подстрока или символ sub находится в пределах среза str[start:end].

            # Работает аналогично методу строки str.find(), за исключением того,
            # что бросает исключение ValueError, если символ или подстрока sub не найдены в строке str.
            # Необязательные аргументы start и end интерпретируются как в нотации среза.
            # Индекс подстроки считается всегда от начала строки, а не от начала среза, если конечно он указан.
            # Метод бросает исключение ValueError, если символ или подстрока sub не найдены.

            # Обратите внимание, что метод str.index() следует использовать только в том случае,
            # если вам нужно узнать положение подстроки sub в строке.
            # Чтобы проверить, является ли sub подстрокой строки str, используйте оператор if ... in
  #  012345678901234567890123456
x = 'раз два три раз два три раз'
x1 = x.index('раз')
print(x1) # 0

print(x.index('раз', 1, 23)) # 12

# print(x.index('четыре')) # Ошибка.
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# ValueError: substring not found

# ____________________________________________________________ 'isalnum' (из цифр и букв) _________________________________________________________________
# Проверяет, что строка состоит только из цифр и буквенных символов.
# Синтаксис:
            # str.isalnum()
# Параметры:
            # нет
# Возвращаемое значение:
                        # bool, True - если строка являются только буквенно-цифровой.
# Описание:
            # Метод str.isalnum() возвращает True, если все символы в строке являются буквенно-цифровыми и
            # есть хотя бы один символ, в противном случае False.
            # Символ c является буквенно-цифровым,
            # если одно из следующих значений возвращает True:
                                                                # char.isalpha(),
                                                                # char.is isdecimal(),
                                                                # char.isdigit(),
                                                                # char.isnumeric().
x = ' '
print(x.isalnum()) # False

x = ''
print(x.isalnum()) # False

x = '123'
print(x.isalnum()) # True

x = 'abcABC'
print(x.isalnum()) # True

x = '123abcABC'
print(x.isalnum()) # True

x = '123-abcABC'
print(x.isalnum()) # False

x = '123.abcABC'
print(x.isalnum()) # False
# ____________________________________________________________ 'isalpha' (только из букв) _________________________________________________________________
#  Метод str.isalpha() в Python, строка состоит только из букв.
# Синтаксис:
            # str.isalpha()
# Внимание! Ссылки для тех, кто ищет:
                                        # как можно проверить наличие/вхождение определенного символа/буквы/подстроки в строке,
                                        # https://docs-python.ru/tutorial/obschie-operatsii-posledovatelnostjami-list-tuple-str-python/prinadlezhnost-elementa-stroki-posledovatelnosti/
                                        # узнать порядковый индекс определенного символа/буквы/подстроки в строке,
                                        # https://docs-python.ru/tutorial/obschie-operatsii-posledovatelnostjami-list-tuple-str-python/metod-posledovatelnosti-index/
                                        # сколько раз встречается определенный символ/буква/подстрока в строке.
                                        # https://docs-python.ru/tutorial/obschie-operatsii-posledovatelnostjami-list-tuple-str-python/metod-posledovatelnosti-count/
# Параметры:
            # нет
# Возвращаемое значение:
                        # bool, True - если строка содержит только буквы
# Описание:
            # Метод строки str.isalpha() возвращает True,
            # если все символы в строке str являются буквенными и
            # есть хотя бы один символ (строка не пустая и не состоит из одного пробела),
            # в противном случае False.

            # Буквенные символы - это символы, определенные в базе данных символов Юникод как “буква”.
            # То есть, те символы, у которых общее свойство категории является одним из Lm, Lt, Lu, Ll или Lo.
            # Обратите внимание, что это определение отличается от понятия “Алфавитный”,
            # определенного в стандарте Unicode.

print(''.isalpha())        # False
print(' '.isalpha())       # False
print('123'.isalpha())     # False
print('abcABC'.isalpha())  # True
print('123abc'.isalpha())  # False
print('123 abc'.isalpha()) # False
print('123-abc'.isalpha()) # False

# ____________________________________________________________ 'isascii' (символ ASCII) _________________________________________________________________
# Метод str.isascii() в Python, все символы в строке являются ASCII.
#  ASCII — это https://blog.skillfactory.ru/glossary/ascii/
#  Синтаксис:
                # str.isascii()
# Параметры:
                # нет
# Возвращаемое значение:
                        # bool, True - если строка состоит только из символов ASCII
# Описание:
            # Метод str.isascii() возвращает True, если строка пуста или все символы в строке str являются ASCII,
            # False в противном случае.
            # Символы ASCII имеют кодовые точки в диапазоне U+0000 - U+007F.
print(''.isascii()) # True
print(' '.isascii()) # True
print('123'.isascii()) # True
print('123abcABC'.isascii()) # True
print('123-abc'.isascii()) # True
print('Привет'.isascii()) # False

# ____________________________________________________________ 'isdecimal' (десятичное число) _________________________________________________________________
# Метод str.isdecimal() в Python, проверяет строку на десятичное число (целые числа)
# Формально десятичный символ - это символ в общей категории Unicode Nd. https://www.fileformat.info/info/unicode/category/Nd/list.htm
# Синтаксис:
            # str.isdecimal()
# Параметры:
            # нет
# Возвращаемое значение:
                        # bool, True - если все символы в строке десятичные
# Описание:
            # Метод str.isdecimal() возвращает True, если все символы в строке str являются десятичными
            # и есть хотя бы один символ (строка является не пустой и не состоит из пробелов),
            # в противном случае False.
            # Категория Unicode Nd включает цифры, а также все символы, которые могут быть использованы для
            # записи чисел этой системы исчисления, такие как U+0660 (ARABIC-INDIC DIGIT ZERO).

print(''.isdecimal())       # False
print(' '.isdecimal())      # False
print('0123۵'.isdecimal())   # True
print('12.3'.isdecimal())   # False
print('12 300'.isdecimal()) # False
print('num'.isdecimal())    # False

# ____________________________________________________________ 'isdigit' (цифра) _________________________________________________________________
# Метод str.isdigit() в Python, строка состоит только из цифр.
# Синтаксис:
            # str.isdigit()
# Параметры:
            # нет
# Возвращаемое значение:
                        # bool, True - если все символы в строке являются цифрами
# Описание:
            # Метод str.isdigit() возвращает True, если все символы в строке str являются цифрами и
            # есть хотя бы один символ (строка является не пустой и не состоит из пробелов),
            # в противном случае False.
            # Цифры включают десятичные символы и цифры, которые требуют специальной обработки,
            # такие как цифры надстрочного индекса совместимости. Это охватывает цифры,
            # которые не могут быть использованы для формирования чисел в базе 10,
            # как числа письменности Кхароштхи.
            # Формально, цифра-это символ,
            # который имеет значение свойства Numeric_Type = Digit или Numeric_Type = Decimal.

print(''.isdigit())         # False
print(' '.isdigit())        # False
print('0123'.isdigit())     # True
print('12.3'.isdigit())     # False
print('12 300'.isdigit())   # False
print('num'.isdigit())      # False

# ____________________________________________________________ 'isidentifier' (идентификатор) _________________________________________________________________
#  Определяет, что строка не является идентификатором языка Python.
# Синтаксис:
            # str.isidentifier()
# Параметры:
            # нет
# Возвращаемое значение:
                        # bool, True - если строка это допустимый идентификатор.
# Описание:
            # Метод str.isidentifier() возвращает True, если строка str является допустимым идентификатором
            # в соответствии с определением языка, в противном случае False.
            # Идентификаторы не ограничены по длине. Их также называют именами функций, переменных и т.д.
            # Другими словами метод проверяет, можно ли использовать проверяемую строку в качестве имени
            # переменной, названия функции, классов, декораторов и так далее.
            # Используйте keyword.iskeyword(), чтобы проверить, является ли строка зарезервированным
            # идентификатором, таким как def или class.

from keyword import iskeyword

print('hello'.isidentifier(), iskeyword('hello')) # True, False
print('def'.isidentifier(), iskeyword('def')) # True, True

print(''.isidentifier())        # False
print('20'.isidentifier())      # False
print('2wo'.isidentifier())     # False
print('my-var'.isidentifier())  # False
print('_'.isidentifier())       # True
print('my_var'.isidentifier())  # True
print('my_func'.isidentifier()) # True
print('MyClass'.isidentifier()) # True
print('j'.isidentifier())       # True

# ____________________________________________________________ 'islower' (нижний, проверка) _________________________________________________________________
# Метод str.islower( ) в Python, проверяет строку на нижний регистр
# Синтаксис:
            # str.islower()
# Параметры:
            # нет
# Возвращаемое значение:
                        # bool, True - если все символы в строке в нижнем регистре
# Описание:
            # Метод str.islower() возвращает True, если все символы в строке имеют нижний регистр (строчные),
            # при этом строка не должна быть пустой, то есть должна иметь хотя бы один символ в нижнем регистре
            # и не состоять из одних пробелов.
            # Метод str.islower() во всех других случаях возвращает False.
            # Строка состоящая из символов не имеющих возможности приведение к нижнему регистру
            # также будет возвращать False.
            # Например выражение '379'.islower() возвращает False.
            # Для приведения символов строки к верхнему регистру используйте метод str.lower().

print(''.islower()) # False
print(' '.islower()) # False
print('20'.islower()) # False
print('20-это двадцать'.islower()) # False
print('Все символы в строке имеют нижний регистр'.islower()) # False
print('все символы в строке имеют нижний регистр'.islower()) # True
print('0, а это ноль'.islower()) # True
print('ё'.islower()) # True

x = 'KKKJjsnwjdwjddjdoOIJmdwkd'
x1 = x.islower()
print(x1) # False

# ____________________________________________________________ 'isnumeric' (числовые, проверка) _________________________________________________________________
# Метод str.isnumeric() в Python, проверяет строку на числовые символы.
# Синтаксис:
            # str.isnumeric()
# Параметры:
            # нет
# Возвращаемое значение:
                        # bool, True - если все символы в строке являются числовыми символами.
# Описание:
            # Метод str.isnumeric() возвращает True, если все символы в строке являются числовыми символами,
            # и есть по крайней мере один числовой символ (строка является не пустой и не состоит из пробелов),
            # False в противном случае.
            # Числовые символы включают в себя проверку на цифровые символы и все символы,
            # которые имеют свойство Unicode numeric value, например U+2155, VULGAR FRACTION ONE FIFTH.
            # Формально числовые символы-это символы со значением свойства Numeric_Type=Digit,
            # Numeric_Type=Decimal или Numeric_Type=Numeric.

print(''.isnumeric())           # False
print(' '.isnumeric())          # False
print('0'.isnumeric())          # True
print('021'.isnumeric())        # True
print('Ⅻ'.isnumeric())         # True
print('⅓'.isnumeric())          # True
print('(3+15j)'.isnumeric())    # False
print('20.5'.isnumeric())       # False

# ____________________________________________________________ 'isprintable' (печатаемый) _________________________________________________________________
# Метод str.isprintable() в Python, проверяет на доступность для печати.
# Синтаксис:
            # str.isprintable()
# Параметры:
            # нет
# Возвращаемое значение:
                        # bool, True - если все символы в строке доступны для печати.
# Описание:
            # Метод str.isprintable() возвращает True, если все символы в строке доступны для печати
            # или строка пуста, в противном случае False.
            # Непечатаемые символы - это символы, определенные в базе данных символов Юникод как "другие"
            # или "разделитель", за исключением пространства ASCII (0x20), которое считается печатаемым.
            # Обратите внимание, что печатаемые символы в этом контексте - это те,
            # которые не должны экранироваться при вызове repr() в строке.
            # Метод не имеет никакого отношения к обработке строк, записанных в sys.stdout или sys.stderr.

print(''.isprintable())                                               # True
print(' '.isprintable())                                              # True
print("все символы в строке 'str' доступны для печати".isprintable()) # True
print('`Ⅻ`'.isprintable())                                           # True
print('все символы в строке  доступны для печати'.isprintable())     # False

# ____________________________________________________________ 'isspace' (является пробелом?) _________________________________________________________________
# Метод str.isspace() в Python, является ли строка пробелом.
# Синтаксис:
            # str.isspace()
# Параметры:
            # нет
# Возвращаемое значение:
                        # bool, True - если все символы в строке доступны для печати
# Описание:
            # Метод str.isspace() возвращает True, если в строке есть только пробелы и если есть
            # хотя бы один пробел (строка не пуста ''), в противном случае False.
            # Символ является пробелом, если в базе данных символов Unicode его общая категория
            # - Zs (разделитель-пробел), либо его двунаправленный класс - один из WS, B или S.

print(''.isspace())                             # False
print(' '.isspace())                            # True
print('                         '.isspace())    # True
print('в строке есть только пробелы'.isspace()) # False

# ____________________________________________________________ 'istitle' (заглавные буквы) _________________________________________________________________
# Метод str.istitle() в Python, проверяет наличие заглавных букв в словах.
# Синтаксис:
            # str.istitle()
# Параметры:
            # нет
# Возвращаемое значение:
                        # bool, True - если каждое слово начинаются с заглавной буквы (верхний регистр)
# Описание:
            # Метод str.istitle() возвращает True, если каждое слово в строке str начинается с заглавной буквы
            # и в ней есть хотя бы один символ в верхнем регистре. Возвращает False в противном случае.
            # Например, заглавные буквы могут следовать только за непрописанными символами,
            # а строчные - только за прописными.

print(''.istitle())                                                         # False
print('а'.istitle())                                                        # False
print('А'.istitle())                                                        # False
print('20'.istitle())                                                       # False
print('Это 20'.istitle())                                                   # True
print('Каждое Слово в Строке `Str` Начинается с Заглавной Буквы'.istitle()) # False
print('Каждое Слово В Строке `Str` Начинается С Заглавной Буквы'.istitle()) # True

# ____________________________________________________________ 'isupper' (верхний регистр?) _________________________________________________________________
# Метод str.isupper() в Python, проверяет строку на верхний регистр.
# Синтаксис:
            # str.isupper()
# Параметры:
            # нет
# Возвращаемое значение:
                        # bool, True - если все слова имеют верхний регистр символов
# Описание:
            # Метод str.isupper() возвращает True, если все символы в строке str прописные
            # (имеют верхний регистр), при этом строка не должна быть пустой,
            # то есть должна иметь хотя бы один символ в верхнем регистре и не состоять из одних пробелов.
            # Метод str.isupper() во всех других случаях возвращает False.
            # Строка состоящая из символов не имеющих возможности приведение к верхнему регистру также будет
            # возвращать False.
            # Например выражение '379'.isupper() возвращает False.
            # Для приведения символов строки к верхнему регистру используйте метод str.upper().

print(''.isupper())                                                         # False
print('а'.isupper())                                                        # False
print('А'.isupper())                                                        # True
print('20'.isupper())                                                       # False
print('Это 20'.isupper())                                                   # False
print('ЭТО 20'.isupper())                                                   # True
print('ВСЕ СИМВОЛЫ в СТРОКЕ ПРОПИСНЫЕ (ИМЕЮТ ВЕРХНИЙ РЕГИСТР)'.isupper())   # False
print('ВСЕ СИМВОЛЫ В СТРОКЕ ПРОПИСНЫЕ (ИМЕЮТ ВЕРХНИЙ РЕГИСТР)'.isupper())   # True

# ____________________________________________________________ 'join' (соединить) _________________________________________________________________
# Метод str.join() в Python, объединяет список строк.
# Синтаксис:
            # str.join(iterable)
# Параметры:
            # str - строка-разделитель,
            # iterable - итерируемый объект с элементами в виде строк.
# Возвращаемое значение:
                        # новая строка.
# Описание:
            # Метод str.join() возвращает строку, которая является конкатенацией (объединением)
            # всех строк-элементов итерируемого объекта iterable.
            # В итоговой строке элементы объединяются между собой при помощи строки-разделителя str.
            # Если в последовательности iterable есть какие-либо НЕ строковые значения,
            # включая байтовые строки bytes, то поднимается исключение TypeError.

# Пример №1:__________________
x = ['возвращает',  'строку',  'которая',
    'является', 'конкатенацией']
line =  ' '.join(x) # объединение списка строк с разделителем "пробел"
print(line) # 'возвращает строку которая является конкатенацией'

line = '\\'.join(x) # в качестве разделителя символ '\'
print(line) # 'возвращает\nстроку\nкоторая\nявляется\nконкатенацией'

line = '\n'.join(x) # в качестве разделителя символ новой строки '\n'
print(line)
# возвращает
# строку
# которая
# является
# конкатенацией

# Пример №2:__________________
# Очень часто метод str.join() используется для формирования какого то итогового сообщения,
# в зависимости от условий в программе. В начале кода определяется пустой список, а по ходу программы,
# в результате проверок, добавляются части выходного сообщения
# (например при проверке корректности заполнения полей формы).
# В примере будем использовать словарь из двух списков -
# error (для ошибок) и message (для итогового сообщения):

# здесь поступают какие то данные, пускай
num = 22 # input('Введите число. Число должно быть целым: ')
name = input('Введите имя, оно должно быть не менее 3-х букв: ')

content = {'message': [], 'error': []}
# далее идет код проверок например:
if num:
    if type(num) is int:
        content['message'].append(f'  - Введено число {num}')
    else:
        content['error'].append(f'  - {num} - это не целое число')
else:
    content['error'].append('  - Вы не ввели число')

if name:
    if len(name) > 3:
        content['message'].append(f'  - Введено имя: {name}')
    else:
        content['error'].append('  - Имя не должно быть короче 3-х букв')
else:
    content['error'].append('  - Вы не ввели имя')

# в конце кода итоговые проверки и вывод сообщения
if content['error']:
    # если есть какие-то ошибки
    content['error'].insert(0, 'При вводе данных возникли ошибки:\n')
    result_message = '\n'.join(content['error'])
else:
    # если все хорошо.
    content['message'].insert(0, 'Результаты ввода данных:\n')
    result_message = '\n'.join(content['message'])

print(result_message)

# Пример №3:__________________
# Как добавить/соединить существующую строку со списком строк.
# Очень просто. Необходимо существующую строку добавить в начало списка методом изменяющихся
# последовательностей sequence.insert(i, x), а затем применить метод str.join().

# Код исполнится за 5 шагов!
line = 'Состав корзины покупателя:' # начальная строка
lst_line = ['- картошка', '- морковь', '- лук', '- чеснок', '- свекла'] # список строк, которые нужно добавить
lst_line.insert(0, line) # вставляем начальную строку по индексу 0 в список
rez = '\n'.join(lst_line) # объединяем список строк по разделителю '\n'
print(rez)  # Состав корзины покупателя:
            # - картошка
            # - морковь
            # - лук
            # - чеснок
            # - свекла

# НЕ ПРИМЕР !!!
# Конечно данную операцию можно осуществить другим способом, при помощи оператора присваивания на месте +=.
# Но такой код будет работать значительно дольше и потреблять больше памяти,
# особенно это заметно, когда строк очень много.
# Это происходит потому, что строка str - это неизменяемый тип и при конкатенации (сложении строк)
# КАЖДЫЙ РАЗ образуется НОВАЯ строка, на что тратятся ресурсы системы:

# код исполнится за 14 шагов.
line = 'Состав корзины покупателя:'
lst_line = ['- картошка', '- морковь', '- лук', '- чеснок', '- свекла'] # список строк, которые нужно добавить
for add_line in lst_line:
    line += f'\n{add_line}'
print(line)
# Состав корзины покупателя:
# - картошка
# - морковь
# - лук
# - чеснок
# - свекла

# ____________________________________________________________ 'ljust' (по левому) _________________________________________________________________
# Метод str.ljust() в Python, ровняет строку по левому краю.
# Синтаксис:
            # str.ljust(width[, filcher])
# Параметры:
            # width - целое число, требуемая длина строки,
            # filcher - символ-заполнитель, по умолчанию пробел ASCII.
# Возвращаемое значение:
                        # измененная строка.
# Описание:
            # Метод str.ljust() вернет новую строку с текстом str, выровненным по левому краю и шириной width.
            # Заполнение строки str выполняется с использованием указанного символа fillchar.
            # По умолчанию используется пробел ASCII.
            # Возвращается строка без изменений, если ширина width меньше или равна len(str).
            # При вызове без аргументов бросает исключение TypeError (требуется как минимум 1 аргумент,
            # передано 0).
            # Чтобы текст в строке выровнять по правому краю воспользуйтесь методом строки str.rjust().

x = 'текст выравнивается по левому краю'

# Без заполнителя `filcher`
print(x.ljust(len(x)+20)) # текст выравнивается по левому краю

print(x.ljust(len(x)+20, '*')) # текст выравнивается по левому краю********************

# Ширина `width` меньше длины центрируемой строки
print(x.ljust(len(x)-10, '*')) # текст выравнивается по левому краю

# print(x.ljust()) - ошибка!
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# TypeError: ljust() takes at least 1 argument (0 given)

# ____________________________________________________________ 'lower' (ниже) _________________________________________________________________
# Метод str.lower() в Python, строку в нижний регистр.
# Синтаксис:
            # str.lower()
# Параметры:
            # нет
# Возвращаемое значение:
                        # измененная копия строки.
# Описание:
            # Метод str.lower() вернет копию строки str, в которой все символы будут преобразованы в нижний регистр.
            # Используемый алгоритм строчных букв описан в разделе 3.13 стандарта Unicode.
            # Для преобразования строки в верхний регистр используйте метод строки str.upper().
            # Для того, что бы каждое слово в строке начиналось с заглавной буквы используйте метод str.title().

x = 'Все Символы Будут Преобразованы В Нижний Регистр'
print(x.lower()) # 'все символы будут преобразованы в нижний регистр'

x = 'ВСЕ СИМВОЛЫ БУДУТ ПРЕОБРАЗОВАНЫ В НИЖНИЙ РЕГИСТР'
print(x.lower()) # 'все символы будут преобразованы в нижний регистр'

# ____________________________________________________________ 'lstrip' (обрезает начало) _________________________________________________________________
# Метод str.lstrip() в Python, обрезает символы в начале строки.
# Синтаксис:
            # str.lstrip([chars])
# Параметры:
            # chars - строка, набор удаляемых символов.
# Возвращаемое значение:
                        # измененная копия строки.
# Описание:
            # Метод str.lstrip() вернет копию строки str с удаленными символами chars в начале строки.
            # Другими словами, обрежет строку str спереди на заданные символы chars.
            # Аргумент chars - это строка, указывающая набор удаляемых символов.
            # Если chars не задан или None, то по умолчанию метод str.lstrip() удаляет пробелы в начале строки.
            # Аргумент chars не является префиксом строки str, скорее всего,
            # это все комбинации его возможных значений.
            # Если требуется обрезать строку с конца, то используйте метод строки str.rstrip().
            # Если требуется удалить заданные символы обоих концов строки используйте метод строки str.strip().

# Без аргумента, удаляет начальные пробелы
x = '   spacious   '
print(x.lstrip()) # 'spacious   '

x = 'www.example.com'
print(x.lstrip('cmowz.')) # 'example.com'

# ____________________________________________________________ 'maketrans' (таблица символов) _________________________________________________________________
# Метод str.maketrans() в Python, создает таблицу преобразования символов для метода str.translate().
# Синтаксис:
            # str.maketrans(x[, y[, z]])
# Параметры:
            # x - словарь или строка символов,
            # y, z - строка символов.
# Возвращаемое значение:
                        # сопоставление, используемое в str.translate().
# Описание:
            # Статический метод str.maketrans() создает и возвращает таблицу преобразования символов,
            # используемую методом строки str.translate().
            # Если метод принимает только один аргумент x, то это должен быть словарь, отображающий
            # порядковые номера Unicode (целые числа) в порядковые номера Unicode
            # символы (строки длиной 1) в строки (произвольной длины) или None.
            # После этого символьные ключи будут преобразованы в порядковые.
            # Если есть два аргумента x и y, то они должны быть строками одинаковой длины,
            # тогда в результирующем сопоставлении, каждый символ в x будет сопоставлен с символом
            # в той же позиции в y. Если строки окажутся неодинаковой длины,
            # то поднимается исключение ValueError: the first two maketrans arguments must have equal length.
            # Если существует третий аргумент z, это должна быть строка, символы которой не будут отображаться,
            # т.е. будут удаляться.

# Вариант № 1:____________________
x = {'а': '0', 'б': '1', 'в': '2', 'г': '3', 'д': '4',
    'е': '5', 'и': '6', 'к': '7', 'л': '8', 'о': '9'} # словарь
string = 'таблицу преобразования символов' # текст для работы
tbl = string.maketrans(x) # преобразовываем текст string с помощью словаря x,
                          # и записываем результат в переменную tbl

print(string.translate(tbl)) # т0186цу пр591р0з920н6я с6м29892
print(type(tbl)) # <class 'dict'> вернулся словарь.

string_end = string.translate(tbl) # метод .translate(....) описан ниже, предпоследнее описание.

print(string_end) # т0186цу пр591р0з920н6я с6м29892
print(type(string_end)) # <class 'str'> вернулась строка.

# Вариант № 2:____________________
x = 'абвгдеикло' # с какими символами работать в тексте.
y = '0123456789' # какие знаки ставить вместо символов для работы.
z = 'цуя' # что совсем исключить в тексте.

string = 'таблицу преобразования символов' # сам текст для работы.

tbl = string.maketrans(x, y, z) # преобразовываем текст string с помощью x, y, z, где:
                                # x - то, какие символы ищем
                                # y - на какие символы замена (сопоставление x и y по индексам)
                                # z - то, что совсем исключаем на выходе из функции .maketrans()
                                # и записываем результат в переменную tbl

print(string.translate(tbl)) # 'т0186 пр591р0з920н6 с6м29892'
print(type(tbl)) # <class 'dict'> вернулся словарь.


# ____________________________________________________________ 'partition' (разделение по первому) _________________________________________________________________
# Метод str.partition() в Python, делит строку по первому совпадению.
# Синтаксис:
            # str.partition(sep)
# Параметры:
            # sep - str, строка (символ) разделитель
# Возвращаемое значение:
                        # tuple кортеж, содержащий 3 строки
# Описание:
            # Метод str.partition() разбивает строку при первом появлении разделителя sep и вернет кортеж,
            # содержащий часть строки str перед разделителем, сам разделитель sep и часть строки str
            # после разделителя.
            # Разделитель sep может содержать как один, так и несколько символов.
            # Если разделитель не найден, вернуть кортеж, содержащий саму строку str,
            # за которой следуют две пустые строки (str, '', '').
            # При вызове метода без аргументов,
            # поднимается исключение TypeError: partition() takes exactly one argument (0 given)

            # В случаях, когда требуется, чтобы деление строки происходило при последнем появлении разделителя,
            # используйте str.rpartition(). Когда требуется разделить строку на список строк по
            # определенному разделителю, используйте str.split().

x = 'один два три раз два три раз два три'
sep = 'раз'
x1 = x.partition(sep)
print(x1)  # ('один два три ', 'раз', ' два три раз два три')
print(type(x1)) # <class 'tuple'>

print(x.partition(' ')) # ('один', ' ', 'два три раз два три раз два три')

print(x.partition('четыре')) # ('один два три раз два три раз два три', '', '')

# ____________________________________________________________ 'removeprefix' (удаляет префикс) _________________________________________________________________
# Метод str.removeprefix() в Python, производит удаление префикса строки, если таковой имеется.
# Синтаксис:
            # str.removeprefix(prefix, /)
# Параметры:
            # prefix - строка-префикс, который необходимо удалить.
# Возвращаемое значение:
                        # копию исходной строки str, без префикса prefix.
# Описание:
            # Если исходная строка str начинается со строки префикса prefix,
            # то метод str.removeprefix() возвращает копию строки без префикса string[len(prefix):].
            # Если префикс prefix в исходной строке str не обнаружен,
            # то метод возвращает копию исходной строки str.
            # Что бы удалить суффикс строки, используйте метод строки str.removesuffix().

x = 'TestHook'
print(x.removeprefix('Test')) # 'Hook'

ine = 'BaseTestCase'
print(line.removeprefix('Test')) # 'BaseTestCase'

# ____________________________________________________________ 'removesuffix' (удаляет суффикс) _________________________________________________________________
# Метод str.removesuffix() в Python, производит удаление суффикса строки, если таковой имеется.
# Синтаксис:
            # str.removesuffix(suffix, /)
# Параметры:
            # suffix - строка-суффикс, который необходимо удалить.
# Возвращаемое значение:
                        # копию исходной строки str, без суффикса suffix.
# Описание:
            # Если исходная строка str заканчивается строкой суффикса suffix,
            # то метод str.removesuffix() возвращает копию строки без суффикса string[:-len(suffix)].
            # Если суффикс suffix в исходной строке str не обнаружен,
            # то метод возвращает копию исходной строки str.

            # Что бы удалить префикс строки, используйте метод строки str.removeprefix().

print('MiscTests'.removesuffix('Tests')) # 'Misc'

line = 'TmpDirMixin'
print(line.removesuffix('Tests')) # 'TmpDirMixin'

# ____________________________________________________________ 'replace' (заменять) _________________________________________________________________
# Метод str.replace() в Python, производит поиск и замену подстроки (символа) в строке.
# Синтаксис:
            # str.replace(old, new[, count])
# Параметры:
            # old - str, подстрока или символ который меняем
            # new - str, подстрока или символ на который меняем
            # count - int, сколько раз меняем
# Возвращаемое значение:
                        # измененная копия строки.
# Описание:
            # Метод str.replace() вернет копию строки, в которой все вхождения подстроки old заменены на
            # подстроку new.
            # Если указан необязательный аргумент count, заменяются только первые вхождения count.
            # Примечание. Производить поиск и замену подстроки/символа в строке можно так же при помощи
            # регулярных выражений, https://docs-python.ru/tutorial/ispolzovanie-reguljarnyh-vyrazhenij-python/
            # используя функцию re.sub(). https://docs-python.ru/standart-library/modul-re-python/funktsija-sub-modulja-re/

# замена обратных кавычек в строке
x = 'все вхождения подстроки `old` заменены на подстроку `new`'
print(x.replace('`', '-')) # 'все вхождения подстроки -old- заменены на подстроку -new-'

# замена обратных кавычек с ограничением в 2 замены
x = '2 вхождения подстроки `old` заменены на подстроку `new`'
print(x.replace('`', '~', 2)) # '2 вхождения подстроки ~old~ заменены на подстроку `new`'

# замена нескольких значений
x = '2 вхождения подстроки `old` заменены на подстроку `new`'
print(x.replace('old', 'старая').replace('new', 'новая')) # 'все вхождения подстроки `старая` заменены на подстроку `новая`'

# примерная реализация функции множественной замены в строке
# здесь еще нужно подумать над проверкой типов в кортежах ...
def replace_fix(line, old_new_num):
    # при итерации по списку распаковываем кортежи на
    # старое и новое значения, а так же `n` - количество замен
    for vals in old_new_num:
        # если кортеж имеет 3 элемента,
        # значит присутствует количество замен
        if len(vals) == 3:
            # распаковываем кортеж
            old, new, n = vals
            # передаем аргументы методу и
            line = line.replace(old, new, n)
        elif len(vals) == 2:
            # распаковываем кортеж
            old, new = vals
            line = line.replace(old, new)
        else:
            # если в кортеже НЕ 2 или 3 элемента,
            # то поднимаем исключение
            raise 'кортеж должен состоять из 2-х или 3-х элементов' # raise - поднимать
    return line

# сохраняем функцию в файл test.py и запускаем
# $ python3 -i temp.py
# исходная строка
line = 'абра-абра-кад-абра'
# элементы кортежа означают:
# ('заменяемое значение','новое значение', количество замен в строке)
replace_val = [('а', 'A', 3), ('б', 'Б'), ('кад', 'КАД')]
new_line = replace_fix(line, replace_val)
print(new_line) # 'AБрA-AБра-КАД-аБра'

# ____________________________________________________________ 'rfind' (найти индекс) _________________________________________________________________
# Метод str.rfind() в Python, возвращает наибольший индекс совпадения символа/подстроки.
# Синтаксис:
            # str.rfind(sub[, start[, end]])
# Параметры:
            # sub - str, подстрока или символ
            # start - int, начало среза
            # end - int, конец среза
# Возвращаемое значение:
                        # int, индекс последнего совпадения.
# Описание:
            # Метод str.rfind() возвращает индекс последнего совпадения подстроки sub в строке str,
            # где подстрока или символ sub находится в пределах среза str[start:end].
            # Другими словами, находит и возвращает индекс по которому обнаруживается конец указанной подстроки
            # в исходной строке str.
            # Необязательные аргументы start и end интерпретируются как в нотации среза.
            # Индекс подстроки считается всегда от начала строки, а не от начала среза, если конечно он указан.
            # Метод возвращает -1, если символ или подстрока sub не найдены.
            # Что бы найти индекс первого совпадения подстроки sub в строке str воспользуйтесь методом str.find().
            # Обратите внимание, что метод str.rfind() следует использовать только в том случае,
            # если вам нужно знать положение подстроки sub в строке. Чтобы проверить,
            # является ли sub подстрокой строки str, используйте оператор if ... in.

x = 'раз два три раз два три раз'
print(x.rfind('раз')) # 24

print(x.rfind('раз', 0, 23)) # 12

print(x.rfind('четыре')) # -1

# ____________________________________________________________ 'rindex' (последний индекс) _________________________________________________________________
# Метод str.rindex() в Python, индекс последнего совпадения в строке.
# Синтаксис:
            # str.rindex(sub[, start[, end]])
# Параметры:
            # sub - str, подстрока или символ;
            # start - int, индекс строки str для начала поиска;
            # end - int, индекс строки str для конца поиска.
# Возвращаемое значение:
                        # int, индекс позиции в строке.
# Описание:
            # Метод str.rindex() возвращает индекс наибольший индекс конца подстроки sub в строке str,
            # где подстрока или символ sub находится в пределах среза str[start:end].
            # Работает аналогично методу строки str.rfind(),
            # за исключением того, что бросает исключение ValueError,
            # если символ или подстрока sub не найдены в строке str.
            # Необязательные аргументы start и end интерпретируются как в нотации среза.
            # Индекс последнего совпадения подстроки sub считается всегда от начала строки str,
            # а не от начала среза, если конечно он указан.
            # Метод бросает исключение ValueError, если символ или подстрока sub не найдены.
            # Обратите внимание, что метод str.rindex() следует использовать только в том случае,
            # если вам нужно узнать положение подстроки sub в строке. Чтобы проверить,
            # является ли sub подстрокой строки str, используйте оператор if ... in:

x = 'раз два три раз два три раз'
print(x.rindex('раз')) # 24

print(x.rindex('раз', 0, 23)) # 12

# print(x.rindex('четыре')) # - ошибка
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# ValueError: substring not found

# ____________________________________________________________ 'rjust' (по правому) _________________________________________________________________
# Метод str.rjust() в Python, ровняет строку по правому краю.
# Синтаксис:
            # str.rjust(width[, filcher])
# Параметры:
            # width - целое число, требуемая длина строки,
            # filcher - символ-заполнитель, по умолчанию пробел ASCII.
# Возвращаемое значение:
                        # измененная строка.
# Описание:
            # Метод str.rjust() вернет новую строку с текстом str, выровненным по правому краю и шириной width.
            # Заполнение строки str выполняется с использованием указанного символа fillchar.
            # По умолчанию используется пробел ASCII.
            # Возвращается строка без изменений, если ширина width меньше или равна len(str).
            # При вызове без аргументов бросает исключение TypeError (требуется как минимум 1 аргумент,
            # передано 0).
            # Чтобы текст в строке выровнять по левому краю воспользуйтесь методом строки str.ljust().

x = 'текст выравнивается по правому краю'

# Без заполнителя `filcher`
x1 = x.rjust(len(x)+20)
print(x1) # '                    текст выравнивается по правому краю'
print(type(x1)) # <class 'str'>

print(x.rjust(len(x)+20, '*')) # '********************текст выравнивается по правому краю'

# Ширина `width` меньше длины центрируемой строки
print(x.rjust(len(x)-10, '*')) # 'текст выравнивается по правому краю'

# print(x.rjust()) - ошибка
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# TypeError: rjust() takes at least 1 argument (0 given)

# ____________________________________________________________ 'rpartition' (разделение по последнему) _________________________________________________________________
# Метод str.rpartition() в Python, разделить строку по последнему совпадению символа/подстроки в строке.
# Синтаксис:
            # str.rpartition(sep)
# Параметры:
            # sep - str, строка (символ) разделитель
# Возвращаемое значение:
                        # tuple кортеж, содержащий 3 строки
# Описание:
            # Метод str.rpartition() разбивает строку при последнем появлении разделителя sep и вернет кортеж,
            # содержащий часть строки str перед разделителем, сам разделитель sep и
            # часть строки str после разделителя.
            # Разделитель sep может содержать как один, так и несколько символов.
            # Если разделитель не найден, вернуть кортеж, содержащий саму строку str,
            # перед которой следуют две пустые строки ('', '', str).
            # При вызове метода без аргументов поднимается исключение:
            # TypeError: partition() takes exactly one argument (0 given)

            # В случаях, когда требуется, чтобы деление строки происходило при первом появлении разделителя,
            # используйте str.partition().
            # Если требуется разделить строку на список строк по определенному разделителю,
            # используйте str.split().

x = 'один два три раз, два три раз два три'
sep = 'раз'
x1 = x.rpartition(sep) # ('один два три раз два три ', 'раз', ' два три')
print(x1)
print(type(x1)) # <class 'tuple'>

print(x.partition(' ')) # ('один два три раз два три раз два', ' ', 'три')

print(x.partition('четыре')) # ('', '', 'один два три раз два три раз два три')

# ____________________________________________________________ 'rsplit' () _________________________________________________________________
# Метод str.rsplit()
# В старых версиях питона не работала функция split, ее заменяла другая альтернатива – rsplit.
# Если быть точнее, то обе эти функции работают одинаково, просто одна из них устарела.

# Источник: https://itstan.ru/python/kak-razbit-stroku-v-python.html

# ____________________________________________________________ 'rstrip' (конец строки) _________________________________________________________________
# Метод str.rstrip() в Python, обрезает символы на конце строки.
# Синтаксис:
            # str.rstrip([chars])
# Параметры:
            # chars - строка, набор удаляемых символов.
# Возвращаемое значение:
                        # измененная копия строки.
# Описание:
            # Метод str.rstrip() вернет копию строки str с удаленными символами chars в конце строки.
            # Другими словами, обрежет строку str сзади на заданные символы chars.
            # Аргумент chars - это строка, указывающая набор удаляемых символов.
            # Если chars не задан или None, то по умолчанию метод str.rstrip() удаляет пробелы в конце строки.
            # Аргумент chars не является суффиксом строки str,
            # скорее всего, это все комбинации его возможных значений.
            # Если требуется обрезать строку с начала, то используйте метод str.lstrip().
            # Если требуется удалить заданные символы обоих концов строки используйте метод строки str.strip().

# Без аргумента, удаляет конечные пробелы
x = '   spacious   '
x1 = x.rstrip()
print(x1) # '   spacious'
print(type(x1)) # <class 'str'>

print('mississippi'.rstrip('ipz')) # 'missis'

# Удаляем символы перевода строки при чтении файла: - Но, как это работает, я пока не понимаю...
# with open('/path/to/file', 'r') as fp:
#     for line in fp:
#         line = line.rstrip('\n\r')
#         ....

# ____________________________________________________________ 'split' (строку на подстроку) _________________________________________________________________
# Метод str.split() в Python, разделит строку на список подстрок по разделителю.
# Синтаксис:
            # str.split(sep=None, maxsplit=-1)
# Параметры:
            # sep=None - str, разделитель. Может содержать как один, так и несколько символов;
            # maxsplit=-1 - int, сколько раз делить строку. По умолчанию -1 - неограниченно.
# Возвращаемое значение:
                        # list, список подстрок.
# Описание:
            # Метод str.split() возвращает список слов (подстрок) в строке,
            # используя sep в качестве разделителя строки str. Если задан maxsplit,
            # то выполняется не более maxsplit разбиений, таким образом,
            # список будет иметь не более maxsplit+1 элементов. Если maxsplit не указан или равен -1,
            # то делаются все возможные разделения строки str.
            # Если указан разделитель sep,
            # то последовательные разделители в обрабатываемой строке не группируются вместе,
            # а считаются разделителями пустых подстрок. Аргумент sep может состоять из нескольких символов.
            # Разбиение пустой строки str с указанным разделителем возвращает значение ["]. Например:

# Вариант № 1:
# Последовательные разделители не группируются вместе,
# и считаются разделителями пустых строк
x = '1,,2'
x1 = x.split (',')
print(x1) # ['1', ", '2'])
print(type(x1)) # <class 'list'>

#Аргумент 'sep' может состоять из нескольких символов.
x = '1<>2<>3'
print(x.split ('<>')) # ['1', '2', '3'])

# Разбиение пустой строки с указанным разделителем.
x = ''
print(x.split(';')) # ['']

# Вариант № 2:
# Если sep не указан или задан None, применяется другой алгоритм разбиения:
# Последовательности пробелов рассматриваются как один разделитель и если строка имеет начальные или
# конечные пробелы, то результат не будет содержать пустых строк в начале или конце.
# Следовательно, разбиение пустой строки или строки, состоящей только из пробела с разделителем None,
# возвращает пустой список [].

# Смотрите так же метод str.rsplit(), который начинает деление строки справа.

x = '1,2,3'
x1 = x.split(',')
print(x1) # ['1', '2', '3']
print(type(x1)) # <class 'list'>

print('1,2,3'.split(',', maxsplit = 1)) # ['1', '2,3']

print('1,2,,3,'.split(',')) # ['1', '2', '', '3', '']

print('1 2 3'.split()) # ['1', '2', '3']

print('1 2 3'.split(maxsplit = 1)) # ['1', '2 3']

print('   1   2   3   '.split()) # ['1', '2', '3']

print('--1-3--2'.split('-')) # ['', '', '1', '3', '', '2']

# ____________________________________________________________ 'splitlines' (по разрывам) _________________________________________________________________
# Метод str.splitlines() в Python, делит текст по символу '\n'. Делит текст на список строк по разрывам строк.
# Синтаксис:
            # str.splitlines([keepends])
# Параметры:
            # keepends - bool, если True - разрывы строк не будут вырезаться
# Возвращаемое значение:
                        # list, список строк.
# Описание:
            # Метод str.splitlines() возвращает список строк, текста str,
            # разделенного по универсальным разрывам строк. Разрывы (разделители) строк не включаются в
            # результирующий список, если не задано значение keepends = True.
            # Универсальные разрывы (разделители) строк представляют собой
            # надмножество escape-последовательностей. https://docs-python.ru/tutorial/strokovye-bajtovye-literaly/escape-posledovatelnosti-python/
# В методе строки str.splitlines()
# определены следующие разделители (разрывы) строк:
                                                    # \n - Перевод строки
                                                    # \r - Возврат каретки
                                                    # \r\n - Возврат каретки + перевод строки
                                                    # \v или \x0b - Табуляция строк
                                                    # \f или \x0c - Подача страницы
                                                    # \x1c - Разделитель файлов
                                                    # \x1d - Разделитель групп
                                                    # \x1e - Разделитель записей
                                                    # \x85 - Следующая строка (контрольный код C1)
                                                    # \u2028 - Разделитель строк
                                                    # \u2029n - Разделитель абзацев

x = 'ab c\n\nde fg\rkl\r\n'
x1 = x.splitlines()
print(x1) # ['ab c', '', 'de fg', 'kl']
print(type(x1)) # <class 'list'>

x = 'ab c\n\nde fg\rkl\r\n'
x1 = x.splitlines(keepends = True)
print(x1) # ['ab c\n', '\n', 'de fg\r', 'kl\r\n']

# В отличие от str.split(), когда задается строка-разделитель sep,
# метод str.splitlines() возвращает пустой список [] для пустой строки,
# а разрыв строки не приводит к дополнительной строке:

#  Метод splitlines() делает:
print("".splitlines()) # []
print("One line\n".splitlines()) # ['One line']

# Для сравнения, split('\n') дает:
print(''.split('\n')) # ['']
print('Two lines\n'.split('\n')) # ['Two lines', '']

# ____________________________________________________________ 'startswith' (начинается...) _________________________________________________________________
# Поиск строк с заданным началом строки в Python.
# Синтаксис:
            # str.startswith(prefix[, start[, end]])
# Параметры:
            # prefix - объект поддерживающий итерацию (кортеж, символ или подстрока).
            # start - int, индекс начала поиска, по умолчанию 0, необязательно.
            # end - int, индекс конца поиска, по умолчанию len(str), необязательно.
# Возвращаемое значение:
                        # bool, True, если префикс prefix совпал.
# Описание:
            # Метод str.startswith() возвращает True, если строка str начинается указанным префиксом prefix,
            # в противном случае возвращает False.
            # Ограничивать поиск начала строки можно необязательными индексами start и end.
            # В этом случае префикс будет искаться от начала среза.
            # Префикс prefix также может быть кортежем префиксов для поиска.
            # Необязательные аргументы start и end интерпретируются как обозначения среза строки и
            # передаются как позиционные аргументы
            # При вызове без аргументов бросает исключение TypeError (требуется как минимум 1 аргумент, передано 0).
            # Для поиска строк с требуемым окончанием используйте метод строки str.endswith().

x = 'начинается указанным префиксом prefix'
x1 = x.startswith('начин')
print(x1) # # True
print(type(x1)) # <class 'bool'>

print(x.startswith('указанным')) # False

print(x.startswith('указанным',11)) # True


# Есть список строк:
x = ['возвращает True',
    'если строка str',
    'начинается указанным',
    'префиксом prefix']

# Нужны строки, которые начинаются на префиксы
prefix = ('если', 'преф')

for item in x:
    if item.startswith(prefix):
        print('YES =>', item)
    else:
        print('NOT =>', item)
# NOT => возвращает True
# YES => если строка str
# NOT => начинается указанным
# YES => префиксом prefix

# ____________________________________________________________ 'strip' (обрежет с обоих концов) _________________________________________________________________
# Метод str.strip() в Python, удаляет начальные и конечные символы в строке.
# Синтаксис:
            # str.strip([chars])
# Параметры:
            # chars - строка, набор удаляемых символов.
# Возвращаемое значение:
                        # измененная копия строки.
# Описание:
            # Метод str.strip() вернет копию строки str с удаленными начальными и конечными символами chars.
            # Другими словами, обрежет строку str с обоих концов. Аргумент chars - это строка,
            # указывающая набор удаляемых символов. Если аргумент chars не задан или None,
            # то по умолчанию удалит пробелы с обоих концов строки.
            # Аргумент chars не является префиксом или суффиксом, все комбинации его значений удаляют как
            # начальные, так и конечные символы строки str.
            # Символы удаляются с начала строки до достижения символа,
            # который не содержится в наборе символов аргумента chars.
            # Аналогичное действие происходит и в конце строки.
            # Если требуется удалить символы только в конце строки, то используйте метод str.rstrip().
            # Если требуется удалить символы только в начале строки, то используйте метод строки str.lstrip().

comment = '   spacious   '
comment_final = comment.strip()
print(comment_final) # 'spacious'
print(type(comment_final)) # <class 'str'>

print('www.example.com'.strip('cmowz.')) # # 'example'


comment_string = '#....... Section 3.2.1 Issue #32 ......'
print(comment_string.strip('.#! ')) # 'Section 3.2.1 Issue #32'

comment_string = '#....... Section 3.2.1 Issue #32 ......?'
print(comment_string.strip('.#! ')) # Section 3.2.1 Issue #32 ......?

# ____________________________________________________________ 'swapcase' (сменит регистр) _________________________________________________________________
# Метод str.swapcase() в Python, сменит регистр символов в строке.
# Синтаксис:
            # str.swapcase()
# Параметры:
            # нет
# Возвращаемое значение:
                        # измененная копия строки.
# Описание:
            # Метод str.swapcase() возвращает копию строки str с прописными символами,
            # преобразованными в строчные и наоборот.
            # Другими словами метод меняет регистр символов в строке str.

            # Обратите внимание, что выражение str.swapcase().swapcase() == str не обязательно верно.

x = 'Метод меНяет Регистр символоВ в стрОке'
x1 = x.swapcase()
print(x1) # 'мЕТОД МЕнЯЕТ рЕГИСТР СИМВОЛОв В СТРоКЕ'
print(type(x1))

print(x.swapcase().swapcase()) # 'Метод меНяет Регистр символоВ в стрОке'

# ____________________________________________________________ 'title' (каждое заглавное) _________________________________________________________________
# Метод str.title() в Python, переводит первую букву каждого слова в строке в верхний регистр.
# Синтаксис:
            # str.title()
# Параметры:
            # нет
# Возвращаемое значение:
                        # измененная копия строки.
# Описание:
            # Метод str.title() возвращает копию строки str, в которой у каждого слова в строке,
            # первый символ имеет верхний регистр, а остальные символы слова переводятся в нижний регистр.
            # Другими словами, метод вернет копию строки, в которой все слова начинаются с заглавной буквы.
            # Алгоритм использует простое независимое от языка определение слова как группы последовательных букв.
            # Определение работает во многих контекстах, но оно означает,
            # что апострофы в сокращениях и притяжениях образуют границы слов,
            # что может не соответствовать желаемому результату
            # Для преобразования строки в верхний регистр используйте метод строки str.upper().
            # Для преобразования строки в нижний регистр используйте метод строки str.lower().

x = 'первое слово в строке начинается с заглавной буквы'
x1 = x.title()
print(x1) # 'Первое Слово В Строке Начинается С Заглавной Буквы'
print(type(x1)) # <class 'str'>

x = 'пЕРВОЕ сЛОВО  строке начинается с загЛаВной букВы'
print(x.title()) # 'Первое Слово В Строке Начинается С Заглавной Буквы'


# Поведение метода с апострофами в сокращениях:
x = "they're bill's friends from the UK"
print(x.title()) # "They'Re Bill'S Friends From The Uk"

# Обходной путь для апострофов может быть создан с использованием регулярных выражений:
import re

def title_case(text):
    return re.sub(r"[A-Za-z]+('[A-Za-z]+)?",
                lambda mo: mo.group(0).capitalize(), text)

title_case(x) # "They're Bill's Friends From The Uk"

# ____________________________________________________________ 'translate' (Транслировать) _________________________________________________________________
# Метод str.translate() в Python, транслировать текст по определенной схеме.
# Синтаксис:
            # str.translate(table)
# Параметры:
            # table - сопоставление, полученное методом str.maketrans().
# Возвращаемое значение:
                        # измененная копия строки.
# Описание:
            # Метод str.translate() возвращает копию строки, в которой каждый символ был сопоставлен и
            # преобразован согласно карте перевода символов table.
            # Таблица (карта) перевода table должна быть объектом,
            # реализующим индексирование через __getitem__(), обычно это сопоставление (словарь) или
            # последовательность. При индексировании по порядковому номеру таблицы Юникод (целому числу),
            # объект table может выполнять любое из следующих действий:
            # возвращать порядковый номер Юникод или строку,
            # чтобы сопоставить символ одному или нескольким другим символам;
            # возвращать None, чтобы удалить символ из возвращаемой строки;
            # вызывать исключение LookupError, чтобы сопоставить символ самому себе.
            # Для создания карты преобразования символов в различные форматы,
            # можно использовать метод строки str.maketrans().

# Вариант № 1:____________________
x = {'а': '0', 'б': '1', 'в': '2', 'г': '3', 'д': '4',
    'е': '5', 'и': '6', 'к': '7', 'л': '8', 'о': '9'} # словарь
string = 'таблицу преобразования символов' # текст для работы
tbl = string.maketrans(x) # преобразовываем текст string с помощью словаря x,
                          # и записываем результат в переменную tbl

print(string.translate(tbl)) # т0186цу пр591р0з920н6я с6м29892
print(type(tbl)) # <class 'dict'> вернулся словарь.

string_end = string.translate(tbl) # метод .translate(....)

print(string_end) # т0186цу пр591р0з920н6я с6м29892
print(type(string_end)) # <class 'str'> вернулась строка.

# Вариант № 2:____________________
x = 'абвгдеикло' # с какими символами работать в тексте.
y = '0123456789' # какие знаки сиавить вместо символов для работы.
z = 'цуя' # что совсем исключить в тексте.

string = 'таблицу преобразования символов' # сам текст для работы.

tbl = string.maketrans(x, y, z) # преобразовываем текст string с помощью x, y, z, где:
                                # x - то, какие символы ищем
                                # y - на какие символы замена (сопоставление x и y по индексам)
                                # z - то, что совсем исключаем на выходе из фукции .maketrans()
                                # и записываем результат в переменную tbl

print(string.translate(tbl)) # 'т0186 пр591р0з920н6 с6м29892'
print(type(tbl)) # <class 'dict'> вернулся словарь.

string_end = string.translate(tbl) # метод .translate(....)

print(string_end) # т0186цу пр591р0з920н6я с6м29892
print(type(string_end)) # <class 'str'> вернулась строка.

# ____________________________________________________________ 'upper' (строку в верхний) _________________________________________________________________
# Метод str.upper() в Python, переведет строку в верхний регистр.
# Синтаксис:
            # str.upper()
# Параметры:
            # нет
# Возвращаемое значение:
                        # измененная копия строки.
# Описание:
            # Метод str.upper() вернет копию строки str с символами, преобразованными в верхний регистр.
            # Обратите внимание, что str.upper().isupper() может быть ложным,
            # если str содержит несвязанные символы или если категория Юникод результирующего символа не
            # является Lu - прописной буквой, а например, Lt - заглавной буквой.
            # Используемый алгоритм преобразования в верхний регистр описан в разделе 3.13 стандарта Unicode.

            # Для преобразования строки в нижний регистр используйте метод строки str.lower().
            # Для того, что бы каждое слово в строке начиналось с заглавной буквы используйте метод str.title().

x = 'Все СимволЫ Будут ПреоБраЗованы в верхний Регистр'
print(x.upper()) # 'ВСЕ СИМВОЛЫ БУДУТ ПРЕОБРАЗОВАНЫ В ВЕРХНИЙ РЕГИСТР'

x = 'все символы будут преобразованы в верхний регистр'
print(x.upper()) # 'ВСЕ СИМВОЛЫ БУДУТ ПРЕОБРАЗОВАНЫ В ВЕРХНИЙ РЕГИСТР'

# ____________________________________________________________ 'zfill' (строку в верхний) _________________________________________________________________
#  Метод str.zfill() в Python, заполняет начало строки нулями.
# Синтаксис:
            # str.zfill(width)
# Параметры:
            # width - int, длина строки.
# Возвращаемое значение:
                        # измененная копия строки.
# Описание:
            # Метод str.zfill() вернет копию строки, у которой начало строки будет заполнено цифрой ASCII 0,
            # до указанной длины width.
            # Начальный префикс знака '+' / '-' обрабатывается путем вставки отступа после символа знака,
            # а не до него.
            # Возвращается исходная строка, если ширина меньше или равна len(str).
            # Вызов метода str.zfill() без аргумента width вызывает исключение -
            # TypeError: takes exactly 1 argument (0 given).

x = '42'
x1 = x.zfill(5)
print(x1) # 00042
print(type(x1)) # <class 'str'>


print("-42".zfill(5)) # '-0042'

print("-42".zfill(1)) # '-42'

# print("-42".zfill()) - ошибка, нет параметра в функции .zfill(_?_)
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# TypeError: zfill() takes exactly 1 argument (0 given)
